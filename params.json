{
  "name": "Eda16-17",
  "tagline": "Contains all practical course deliveries for the subject \"Estructuras de Datos y Algoritmos\" from the college \"UPV/EHU EUITI Bilbao\"",
  "body": "#Practica. Actividad 2.\r\n\t\t\t\tUPV-EHU 2016/2017\r\n                            \r\n                            \r\n                            \r\n                Estructuras de Datos y Algoritmos\r\n                          \r\n\r\n              \r\n              \r\n                \r\n                \r\n                \t\t\t\t\t\t\t\t\t\t\tJosu Alvarez\r\n                                                            David Max\r\n\r\n* * * *\r\n##Indice\r\n\r\nMas informacion en la pagina web del proyecto: [GITHUB](http://txusyk.github.io/EDA16-17/): http://txusyk.github.io/EDA16-17/\r\n\r\n* * *\r\n\r\n##1. Introducción\r\n\r\n**Siguiendo las indicaciones que nos dejaste en la evaluación de la primera actividad, hemos implementado una versión del algoritmo de ordenacion** (*QuickSort*) **mas simplificada y menos confusa**.\r\n\r\n**Se han completado y probado todas las clases** que entregaste y los test, respectivamente. ** Hemos implementado la parte opcional del *OrderedCircularLinkedList* **(FilmList) y *UnorderedCircularLinkedList* (ActorList). Hemos decidido añadirlas a dichas clases dado que **si sustituiamos el HashMap< String, T > que tenemos para los catálogos de actores y peliculas el coste del programa se nos disparaba**. Por lo tanto, **desde la perspectiva de la eficiencia, hemos decidido que** dichas estructuras de datos **manejen menos volumen de información.**\r\n\r\n**Dado un fichero de datos** que contiene actores y actrices de Internet Movie DataBase (IMDB), con una estructura efinida ('nombrePelicula' ---> 'nombreActor1' &&& 'nombreActor2'...) . **Se ha de implementar un programa que cargue el fichero de datos y extraiga del mismo los nombres de los actores y las peliculas que contiene**.\r\n\r\n**El pilar del funcionamiento de nuestro programa son las búsquedas**. Dado que tanto para añadir, eliminar como para gestionar alguno de los datos previamente se hará una búsqueda para comprobar si realmente existe.\r\n\r\nDado que disponiamos de tiempo y que el proyecto nos ha parecido interesante, **hemos decidido implementar ciertas mejoras sobre el trabajo inicial**, siendo estas:\r\n\r\n- ** El sistema dará la opción** al usuario para que decida como quiere ejecutar el programa, si por la **consola o bien mediante una GUI** que hemos construido con Swing.\r\n- **Hay dos formas de cargar el archivo**, una **con todos los datos y** otra **con los datos normalizados** (se explica mejor en las proximas lineas).\r\n- **Todo el proyecto** y todas sus versiones estan **siendo manejadas mediante GitHub**, se ha dispuesto una pagina web publica que contiene esta misma información y será actualizada con cada una de las proximas entregas.\r\n- **Uso exclusivo de lenguaje 'Markdown' para proceder a documentar el codigo**. En nuestro esfuerzo por usar tecnologías libres y ser eficientes, hemos encontrado este lenguaje ideal (dada su total compatibilidad con las wikis y las webs de GitHub).\r\n- **Uso del ingles** siempre que nos ha sido posible, para desarrollar el codigo de forma universal y que cualquier programador interesado lo pueda revisar, utilizar o mejorar desde el GitHub habilitado para ello.\r\n\r\n**Hemos definido que el programa cumpla** las siguientes funciones:\r\n\r\n1. ***Carga de datos desde fichero:* ** Se dará a elegir al usuario si quiere cargar la lista completa o solo querrá cargar los actores/peliculas que se encuentren bien escritos, es decir, que sean legibles tras haber sido tratados con un método que hemos establecido para normalizar nombres en base a caracteres desconocidos.\r\n1. ***Búsqueda de un actor/película:* ** Devolvera el actor en caso de existir, en caso contrario dará un aviso por terminal/pop-up.\r\n1. ***Inserción de un actor/película:* ** Indica si ha sido posible añadir el actor o si el mismo existía previamente.\r\n1. ***Eliminación de un actor/película:* ** Indica si el actor existe y en ese caso, que ha sido borrado. En caso contrario informará de que no existe.\r\n1. ***Obtener la lista de peliculas de un actor:* * ** Comprueba que el actor exista, y en caso positivo, muestra la lista de peliculas del mismo\r\n1. ***Obtener la lista de actores de una pelicula (reparto):* **  Comprobamos que la pelicula existe previamente y en caso positivo, imprimimos por pantalla los actores que la componen. En caso de no existir, se informará de dicha situación al usuario.\r\n1. ***Modificar el presupuesto de una pelicula:* ** Comprobamos que la pelicula introducida existe previamente y si es así, incrementamos el valor de recaudación en X (donde X es el valor introducido por el usuario). En caso de no existir la pelicula, se informará de dicha siatuación al usuario.\r\n1. ***Obtener una lista de actores ordenada (nombre, apellido):* ** Obtenemos una lista de actores ordenados bajo el criterio: Nombre Apellido (separados unicamente por un espacio)\r\n1. ***Exportar los datos a un fichero de texto:* ** Exportamos la lista ordenada de los actores, con sus respetivas peliculas a un fichero de texto `.txt`\r\n\r\n\r\n* * *\r\n\r\n## 2. Diagrama de clases\r\n\r\nEste es el diseño final del programa, los diseños iniciales y la evolución de los mismos hasta llegar a esta se encuentran en nuestro GitHub.\r\n\r\n![](/Users/Josu/Desktop/uml2.png)\r\n\r\n\r\n* * *\r\n\r\n\r\n## 3. Descripción de las estructuras de datos principales\r\n\r\nComo comentábamos en la introducción del documento, **la parte más importante** del documento recae en los métodos que realizan **las búsquedas**. Dado que **son necesarios para trabajar la información, añadir y eliminarla**.\r\n\r\nTal como comentamos en la primera actividad, hicimos diferentes pruebas: búsqueda lineal y dicotómica. **Finalmente, vimos que podriamos tratar las búsquedas casi como un coste constante** si utilizabamos alguna estructura de datos de la familia **'Map'**. Por eso, replanteamos el diseño del programa e **hicimos que todas las estructuras de datos con las que trabajamos sean *HashMap < String, T >* ** donde 'T' es cualquier objeto que necesitemos almacenar (peliculas, actores...).\r\n\r\nTeniendo en cuenta lo que se pedía para cumplimentar la segunda actividad. Hemos decidido implementar:\r\n- ** *OrderedCircularLinkedList* ** en la clase ActorList (que contendrá el reparto de cada una de las peliculas).\r\n- ** *UnorderedCircularLinkedList* ** en la clase FilmList (que contendrá la filmografia de cada actor)\r\n\r\nComo **algoritmo de ordenación**, utilizábamos BubbleSort. Decidimos hacer modificaciones debido a que su coste era demasiado alto para lo que buscábamos (*O(n2)*). Hicimos distintas pruebas con MergeSort, aunque **finalmente optamos como algoritmo por el QuickSort reduciendo así el coste hasta O(n* log n)**.\r\nPara realizar **la operación de ordenación**, previamente **volcamos las claves de nuestro HashMap** (que son los nombres de los actores) **en un Array[] de String y procedemos a ordenarlo**. **Tras esto, recibiremos una lista de claves ordenadas**, que en caso de querer mostrar unicamente los nombres de los actores cumple al 100% la función y en caso de querer mostrar mas información, lo recorreremos en orden y accederemos con cada clave a la información de nuestro catálogo (HashMap).\r\n**Tal y como comentábamos en la introducción del documento, hemos simplificado nuestra versión del *QuickSort* ** y ahora es mucho mas sencilla.\r\n\r\n## 4. Diseño e implementacion de los metodos principales\r\n\r\nEste apartado lo dedicaremos a explicar el funcionamiento de los diferentes métodos principales de las clases a implementar en este laboratorio.\r\n\r\n###4.1. CircularLinkedList:\r\n\r\n####4.1.1 removeFirst()\r\n\r\n#####4.1.1.1 Precondicion/Postcondicion\r\n++Precondicion:++ Tendremos una lista de punteros\r\n++Postcondicion:++ Tendremos la lista, sin el primer elemento.\r\n\r\n#####4.1.1.2 Casos de prueba\r\n* Lista null\r\n\r\n#####4.1.1.3 Coste\r\n\r\nEl coste de esta operacion sera constante ***O(1)* **, ya que las operaciones que se harían son de coste constante, y las haremos sobre el primer el elemento al que accedemos.\r\n\r\n#####4.1.1.4 Pseudo-algoritmo\r\n\r\n\t\tNodo <T> primero = ultimo.sig;\r\n        si(tamaño() == 1){\r\n        \tultimo = null;\r\n        }\r\n        sino{\r\n        \tultimo.sig = ultimo.sig.sig;\r\n        }\r\n        count--;\r\n        return primero.info;\r\n\r\n####4.1.1.5 Método final\r\n\r\n```java\r\npublic T removeFirst() {\r\n        // Elimina el primer elemento de la lista\r\n        // Precondici�n: la lista tiene al menos un elemento\r\n        // COMPLETAR EL CODIGO Y CALCULAR EL COSTE\r\n\r\n        // Elimina el primer elemento de la lista\r\n        // Precondici�n: la lista tiene al menos un elemento\r\n        // COMPLETAR EL CODIGO Y CALCULAR EL COSTE\r\n\r\n        Node<T> first = last.next;\r\n        if (size() == 1) {\r\n            last = null;\r\n        } else {\r\n            last.next = last.next.next;\r\n        }\r\n        count--;\r\n        return first.data;\r\n    }\r\n```\r\n#### 4.1.2 removeLast()\r\n##### 4.1.2.1 Precondición/Postcondición\r\n- ++Pre:++ Tendremos una lista de punteros.\r\n- ++Post:++ Tendremos la lista sin el ultimo elemento.\r\n\r\n##### 4.1.2.2 Casos de prueba\r\n- Lista null\r\n\r\n##### 4.1.2.3 Coste\r\n\r\nEl coste de este método será lineal ***O(n)* **, ya que tendremos que recorrer la lista entera antes de colocarnos delante del ultimo elemento para proceder a eliminarlo.\r\n\r\n##### 4.1.2.4 Pseudo-algoritmo\r\n\r\n```\r\n\tsi(tamaño() == 1){\r\n    \tlast = null;\r\n    }\r\n    sino{\r\n    \tNodo <T> actual = ultimo.sig;\r\n        mientras(actual.sig != ultimo){\r\n        \tactual = actual.sig;\r\n        }\r\n        ultimo = actual;\r\n        ultimo.sig = ultimo.sig.sig;\r\n    }\r\n    cont --;\r\n    return last.data;\r\n\r\n```\r\n\r\n##### 4.1.2.5 Metodo final (código)\r\n\r\n```java\r\npublic T removeLast() {\r\n        // Elimina el �ltimo elemento de la lista\r\n        // Precondici�n: la lista tiene al menos un elemento\r\n        // COMPLETAR EL CODIGO Y CALCULAR EL COSTE\r\n        Node<T> pLast = last;\r\n        if (size() == 1) {\r\n            last = null;\r\n        } else {\r\n            Node<T> current = last.next;\r\n            while (current.next != last) {\r\n                current = current.next;\r\n            }\r\n            last = current;\r\n            last.next = last.next.next;\r\n        }\r\n        count--;\r\n        return pLast.data;\r\n    }\r\n\r\n```\r\n\r\n* * *\r\n####4.1.3 remove()\r\n\r\n\r\n#####4.1.3.1 Precondicion/Postcondicion\r\n- ++Precondicion:++ Tendremos un elemento de una lista.\r\n- ++Postcondicion:++ Tendremos la lista sin el elemento.\r\n\r\n#####4.1.3.2 Casos de prueba\r\n* Lista null\r\n* Elemento no existente en la lista.\r\n* El elemento a añadir es nulo.\r\n\r\n####4.1.3.3 Coste\r\nEste algoritmo tendra un coste de ***O(n)* ** en el peor de los casos, ya que suponiendo que el ultimo elemento sea el que queremos eliminar, tendremos que recorrer la lista entera.\r\nPero en caso de que sea el primer elemento el que queremos eliminar, el coste del algoritmo sería constante ***O(1)* ** ya que nos valdria con acceder al primer elemento mediante el puntero 'first'.\r\n\r\n####4.1.3.4 Pseudo-algoritmo\r\n\tpublic T remove(T elem) {\r\n\t\tNodo <T> actual = primero;\r\n    \tint i = 0;\r\n    \tT numReturn;\r\n\r\n    \tsi(this.vacio()){\r\n    \t\treturn null;\r\n    \t}\r\n    \tsino{\r\n    \t\tmientras(!actual.sig.info.igual(elem)){\r\n        \t\tactual = actual.sig;\r\n            \ti++;\r\n        \t}\r\n\t\t\tsi(i==cont){\r\n        \t\tSystem.out.println(\"El elemento no esta\");\r\n            \treturn null;\r\n        \t}\r\n        \tsino{\r\n        \t\tsi(cont == 1){\r\n            \t\tnumReturn = last.data;\r\n                \tlast=null;\r\n            \t}\r\n            \telse{\r\n            \t\tnumReturn = actual.next.data;\r\n\r\n                \tsi(actual.sig == ultimo){\r\n                \t\tultimo = actual;\r\n                \t}\r\n                \tactual.sig = actual.sig.sig;\r\n            \t}\r\n            \tcont--;\r\n            \tSystem.out.println(\"\\n -> \"+elem+\" no ha sido eliminado);\r\n            \treturn numReturn\r\n        \t}\r\n        }\r\n\r\n\r\n\r\n####4.1.3.5 Método final\r\n\r\n```java\r\n public T remove(T elem) {\r\n        Node<T> current = last;\r\n        int i = 0;\r\n        T returnNum;\r\n\r\n        if (this.isEmpty()){ return null;} //if its empty we return null\r\n        else{//if not null\r\n            while(!current.next.data.equals(elem) && i!=size()){//goes out when finds the element or overpass the size\r\n                current = current.next;\r\n                i++;\r\n            }\r\n            if (i==count){//if the elemente isn't finded\r\n                System.out.println(\"The element isn't finded\");\r\n                return null;\r\n            }else{//we find it. we have to remove currents pointing node\r\n                if (count == 1){//if we only have one element\r\n                    returnNum = last.data;\r\n                    last = null;\r\n                }else{//if are more elements than 1\r\n                    returnNum = current.next.data;\r\n\r\n                    if (current.next == last) {\r\n                        last = current;//if the element is the last we dont lose the pointer, we give it to the previous item\r\n                    }\r\n                    current.next = current.next.next;\r\n                }\r\n                count--;\r\n                System.out.println(\"\\n ->  \"+elem+\" it's been deleted\");\r\n                return returnNum;\r\n            }\r\n        }\r\n    }\r\n\r\n```\r\n\r\n####4.1.5 find()\r\n\r\n#####4.1.5.1 Precondicion/PostCondicion\r\n- ++Precondición++: El programa recibe un elemento\r\n- ++Postcondición++: Nos devolvera el numero si lo ha encontrado, y null si no existe.\r\n\r\n#####4.1.5.2 Casos de prueba\r\n* Lista vacía\r\n* El elemento a añadir es nulo.\r\n\r\n#####4.1.5.3 Coste\r\nEl coste de este algoritmo será en el peor de los casos ***O(n)* ** ya que tendremos que recorrer la lista hasta su ultimo elemento para eliminarlo.\r\nPero en el mejor de los casos el coste sería costante ***O(1)* **, ya que nos valdría el puntero first para acceder al primer elemento.\r\n\r\n#####4.1.5.4 Pseudo-algoritmo\r\n\r\n\tpublic T find(T elem) {\r\n        //Determina si la lista contiene un elemento concreto, y develve su referencia, null en caso de que no est�\r\n        // COMPLETAR EL CODIGO Y CALCULAR EL COSTE\r\n        Integer i = 0;\r\n        T numReturn;\r\n        Nodo<T> actual = ultimo;\r\n\r\n        si(this.esVacio()){\r\n        \treturn null;\r\n        }\r\n        sino{\r\n        \tmientras(!actual.data.igual(elem) && i!=tamaño()){\r\n            \tactual = actual.next;\r\n                i++;\r\n            }\r\n            if(i==cont){\r\n            \treturn null;\r\n            }\r\n            sino{\r\n            \tnumReturn = actual.data;\r\n\t\t\t\treturn numReturn;\r\n            }\r\n        }\r\n\t}\r\n\r\n\r\n\r\n#####4.1.5.5 Método final\r\n\r\n```java\r\npublic T find(T elem) {\r\n        //Determina si la lista contiene un elemento concreto, y develve su referencia, null en caso de que no está\r\n        // COMPLETAR EL CODIGO Y CALCULAR EL COSTE\r\n        Integer i = 0;\r\n        T returnNum;\r\n        Node<T> current = last;\r\n\r\n        if(this.isEmpty()){\r\n            return null;\r\n        }\r\n        else{//si hay elementos, buscamos nuestro elemento\r\n            while(!current.data.equals(elem) && i!=size()){//tiene que salir si recorre todos los elementos\r\n                current = current.next;\r\n                i++;\r\n            }\r\n            if(i==count){//no lo ha encontrado\r\n                return null;\r\n            }\r\n            else{//lo a encontrado\r\n                returnNum = current.data;\r\n                return returnNum;\r\n            }\r\n\r\n        }\r\n    }\r\n```\r\n\r\n\r\n###4.2 UnorderedCircularLinkedList\r\n\r\n####4.2.1 addToFront()\r\n\r\n#####4.2.1.1 Precondicion/Postcondicion\r\n- ++Precondicion:++ El programa recibira un elemento.\r\n- ++Postcondicion:++ El elemento esta añadido en la primera posición de la lista.\r\n\r\n#####4.2.1.2 Casos de prueba\r\n* La lista es nula.\r\n* El elemento a añadir es nulo.\r\n\r\n#####4.2.1.3 Coste\r\nEl coste de este algoritmo sera constante ***O(1)* ** ya que el elemento se añadira a la primera posición de la lista, posición a la cual accederemos directamente mediante el puntero 'first'.\r\n\r\n#####4.2.1.4 Pseudo-algoritmo\r\n\r\n\tpublic void addToFront(T elem){\r\n        Nodo<T> auxN = nuevo Nodo<T>(elem);\r\n        si(esVacia()){\r\n        \tultimo = auxN;\r\n        }\r\n        sino{\r\n        \tauxN.sig = ultimo.sig;\r\n            ultimo.sig = auxN;\r\n        }\r\n        cont++;\r\n\t}\r\n\r\n#####4.2.1.5 Método final\r\n\r\n```java\r\npublic void addToFront(T elem){\r\n\r\n        Node<T> newNode = new Node<T>(elem);\r\n\t\tif(isEmpty()){\r\n\t\t\tlast = newNode;\r\n            last.next = last;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tnewNode.next = last.next;\r\n\t\t\tlast.next = newNode;\r\n\t\t}\r\n\t\tcount++;\r\n\t}\r\n\r\n```\r\n\r\n####4.2.2 addToRear()\r\n\r\n#####4.2.2.1 Precondición/Postcondición\r\n- ++Precondición:++ El programa recibe un elemento.\r\n- ++Postcondición:++ El programa habra añadido ese elemento al final de la lista.\r\n\r\n#####4.2.3.2 Casos de prueba\r\n* La lista es nula.\r\n* El elemento a añadir es nulo.\r\n\r\n#####4.2.3.3 Coste\r\nEl coste de este algoritmo será constante ** *O(1)* **, ya que gracias al puntero 'last' accederemos a la ultima posición directamente, y así podremos añadir en un solo paso el elemento al final de la lista.\r\n\r\n#####4.2.3.3 Pseudo-algoritmo\r\n\tpublic void addToRear(T elem) {\r\n    \tNodo <T> auxN = nuevo Nodo<T>(elem);\r\n    \tsi(esVacia()){\r\n        \tultimo = auxN;\r\n            ultimo.sig = ultimo;\r\n        }\r\n        sino{\r\n        \tauxN.sig = ultimo.sig;\r\n            ultimo.sig = auxN;\r\n            ultimo = auxN;\r\n        }\r\n        cont++;\r\n\t}\r\n\r\n####4.2.3 addAfter()\r\n\r\n#####4.2.3.1 Precodición/Postcondición\r\n- ++Precondición:++ Recibiremos 2 elementos, el primero será el que tendremos que añadir a la lista, y el segundo sera el objetivo detras del cual deberemos añadir el elemento.\r\n- ++Postcondición:++ El primer elemento se habra colocado detras del segundo.\r\n\r\n#####4.2.3.2 Casos de prueba\r\n* Lista nula.\r\n* Elemento a añadir nulo.\r\n* Elemento objetivo nulo.\r\n\r\n#####4.2.3.3 Coste\r\nEl coste de este algoritmo en el peor de los casos será ***O(n)* ** ya que tendremos que recorrer la lista elemento tras elemento hasta encontrar el objetivo. Pero en caso de que el objetivo sea el ultimo elemento, el coste sera constante ***O(1)* ** ya que empezaremos a recorrer la lista desde el último elemento.\r\n\r\n#####4.2.3.4 Pseudo-algoritmo\r\n\tpublic void addAfter(T elem, T objetivo) {\r\n        Nodo<T> auxN = nuevo Nodo<T>(elem);\r\n        Nodo<T> actual = ultimo;\r\n\r\n        mientras(!actual.info.igual(objetivo)){\r\n        \tactual = actual.sig;\r\n        }\r\n        auxN.sig = actual.sig;\r\n        actual.sig = auxN;\r\n        cont++;\r\n\t}\r\n\r\n#####4.2.3.5 Método final\r\n```java\r\npublic void addAfter(T elem, T target) {\r\n        Node<T> newNode = new Node<T>(elem);\r\n\t\tNode<T> current = last;\r\n\r\n\t\twhile(!current.data.equals(target)){\r\n\t\t\tcurrent = current.next;\r\n\t\t}\r\n\t\tnewNode.next = current.next;\r\n\t\tcurrent.next = newNode;\r\n\t\tcount++;\r\n}\r\n\r\n```\r\n\r\n###4.3 OrderedCircularLikedList\r\n\r\n####4.3.1 add()\r\n\r\n#####4.3.1.1 Precondición/Postcondición\r\n- ++Precondición:++ El programa recibirá un elemento a añadir.\r\n- ++Postcondición:++ El programa habrá añadido el elemento ordenadamente.\r\n\r\n#####4.3.1.2 Casos de prueba\r\n* Lista nula.\r\n* El elemento a añadir es nulo.\r\n\r\n#####4.3.1.3 Coste\r\nEl coste de este algoritmo será ***O(n)* ** ya que tendremos que recorrer la lista elemeento tras elemento hasta encontrar la posicion en la que debemos insertar el dato en cuestión.\r\n\r\n#####4.3.1.4 Pseudo-algoritmo\r\n\tpublic void add(T elem) {\r\n        Nodo<T> actual;\r\n        Nodo<T> auxN = nuevo Nodo<T>(elem);\r\n        booleano enc = false;\r\n\r\n        si (cont == 0 ? true : false){\r\n        \tultimo = auxN;\r\n            auxN.sig = auxN;\r\n        }\r\n        sino{\r\n        \tactual = ultimo.sig;\r\n            si(actual.info.compararCon(elem)){\r\n            \tauxN.sig = ultimo.sig;\r\n                ultimo.sig = auxN;\r\n            }\r\n            sino si(ultimo.info.compararCon(elem)<0){\r\n            \tauxN.sig = ultimo.sig;\r\n                ultimo.sig = auxN;\r\n                ultimo = auxN\r\n            }\r\n            sino{\r\n            \tmientras(!enc){\r\n                \tif(current.info.compararCon(elem)<0 && actual.sig.info.compararCon(elem) > 0){\r\n                    \tauxN.sig = actual.sig;\r\n                        actual.sig = auxM;\r\n                        enc = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        cont++;\r\n    }\r\n\r\n\r\n#####4.3.1.5 Método final\r\n```java\r\npublic void add(T elem) {\r\n        Node<T> current;    //pointer\r\n        Node<T> auxNode = new Node<T>(elem); //auxiliar pointer\r\n        boolean finded = false; //flag for while\r\n\r\n        if (count == 0 ? true : false) {//if it's empty\r\n            last = auxNode;\r\n            auxNode.next = auxNode;\r\n        } else {\r\n            current = last.next;//first element\r\n            if (current.data.compareTo(elem) > 0) {//if the first is > elem\r\n                auxNode.next = last.next;\r\n                last.next = auxNode;\r\n\r\n            } else if (last.data.compareTo(elem) < 0) {//if the last < auxNode\r\n                auxNode.next = last.next;\r\n                last.next = auxNode;\r\n                last = auxNode;\r\n            } else { //between two elements\r\n                while (!finded) {\r\n                    if (current.data.compareTo(elem) < 0 && current.next.data.compareTo(elem) > 0) { //if whe've finded where to insert\r\n                        auxNode.next = current.next;\r\n                        current.next = auxNode;\r\n                        finded = true;\r\n                    }\r\n                    current = current.next;\r\n                }\r\n            }\r\n        }\r\n        count++;\r\n    }\r\n```\r\n\r\n### 4.4. StringQuickSort (Nueva implementación)\r\n\r\n#### 4.4.1 QuickSort (Nueva implementación)\r\n\r\n#####4.4.1.1 Precondición/Postcondición\r\n\r\n- ++Pre++: Tenemos una lista que queremos ordenar (en ocasiones puede estar casi ordenada o puede llamarse de nuevo a la función de ordenación y por lo tanto estar totalmente ordenada)\r\n- ++Post++: Devolveremos la lista que recibimos como parámetro una vez ordenada por (Nombre, Apellido)\r\n\r\n#####4.4.1.2 Casos de prueba\r\n\r\n- Lista vacía\r\n- Lista no vacía\r\n\r\n#####4.4.1.3 Coste\r\n\r\nEn el mejor caso, el pivote termina en el centro de la lista, dividiéndola en dos sublistas de igual tamaño. En este caso, el orden de complejidad del algoritmo es O(n·log n) .\r\nEn el peor caso, el pivote termina en un extremo de la lista. El orden de complejidad del algoritmo es entonces de O(n²) . El peor caso dependerá de la implementación del algoritmo, aunque habitualmente ocurre en listas que se encuentran ordenadas, o casi ordenadas.\r\nEn el caso promedio, el orden es O(n·log n) .\r\n\r\n#####4.4.1.4 Pseudo algoritmo\r\n\r\n\tpublic void quickSort(T[] laTabla){\r\n\t\tquickSort(laTabla, 0, laTabla.length-1);\r\n\t}\r\n\r\n\tprivate void quickSort(T[] tabla, int inicio, int fin){\r\n\t\tif ( fin - inicio > 0 ) { // hay más de un elemento en la tabla\r\n\t\tint indiceParticion = particion(tabla, inicio, fin);\r\n\t\tquickSort(tabla, inicio, indiceParticion - 1);\r\n\t\tquickSort(tabla, indiceParticion + 1, fin);\r\n\t}\r\n\r\n\tprivate int particion(T[] tabla, int i, int f){\r\n\t\tT pivote = tabla[i];\r\n\t\tint izq = i;\r\n\t\tint der = f;\r\n\t\twhile ( izq < der ){\r\n\t\t\twhile ( tabla[izq].compareTo(pivote) <= 0 && izq < der)\r\n\t\t\t\tizq++;\r\n\t\t\t}\r\n\t\t\twhile ( tabla[der].compareTo(pivote) > 0 )\r\n\t\t\t\tder--;\r\n\t\t\t}\r\n        \tif ( izq < der ){\r\n\t\t\t\tswap(tabla, izq, der);\r\n\t\t\t}\r\n\t\t}\r\n\t\ttabla[i] = tabla[der];\r\n\t\ttabla[der] = pivote;\r\n\t\treturn der;\r\n\t}\r\n\r\n\r\n#####4.4.1.5 Método final\r\n\r\n```java\r\npublic static void quickSort(String[] table){\r\n        quickSort(table, 0, table.length-1);\r\n    }\r\n\r\n    private static void quickSort(String[] table, int start, int end){\r\n        if(end-start > 0){\r\n            int partitionIndex = partition(table, start, end);\r\n            quickSort(table, start, partitionIndex-1);\r\n            quickSort(table, partitionIndex + 1, end);\r\n        }\r\n    }\r\n\r\n    private static int partition(String[] table, int s, int e){\r\n        String pivote = table[s];\r\n        int left = s;\r\n        int right = e;\r\n\r\n        while(left < right){\r\n            while(table[left].compareTo(pivote) <= 0 && left<right){\r\n                left++;\r\n            }\r\n            while(table[right].compareTo(pivote) > 0){\r\n                right--;\r\n            }\r\n            if(left < right){\r\n                swap(table, left, right);\r\n            }\r\n        }\r\n        table[s]=table[right];\r\n        table[right] = pivote;\r\n\r\n        return right;\r\n    }\r\n\r\n    public static void swap(String[] table, int l, int r){\r\n        String temp = table[l];\r\n        table[l] = table[r];\r\n        table[r] = temp;\r\n```\r\n\r\n## 5. Código\r\n\r\nEl resto de las clases se entregan en una carpeta que contiene las clases necesarias de la primera actividad anexas a las de la segunda y junto a todas, se encuentra una carpeta con los test que entregaste modificados por nosotros para hacerlos más personales.\r\n\r\n### 5.1 Clase Actor\r\n\r\n```java\r\n\r\npackage lab2;\r\n\r\n/**\r\n * Created by Josu on 25/09/2016.\r\n */\r\npublic class Actor {\r\n\r\n    private String name;\r\n    private String surname;\r\n    private FilmList filmL;\r\n\r\n    public Actor(String pName, String pSurname) {\r\n        this.name = pName;\r\n        this.surname = pSurname;\r\n        this.filmL = new FilmList();\r\n    }\r\n\r\n    public FilmList getFilmList() {\r\n        return this.filmL;\r\n    }\r\n\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    public String getSurname() {\r\n        return this.surname;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 5.2 Clase ActorCatalog\r\n\r\n```java\r\n\r\npackage lab2;\r\n\r\nimport java.util.HashMap;\r\n\r\n/**\r\n * Created by Josu on 25/09/2016.\r\n */\r\npublic class ActorCatalog {\r\n\r\n    private static ActorCatalog myActorCatalog;\r\n    private HashMap<String, Actor> actorL;\r\n\r\n    private ActorCatalog() {\r\n        this.actorL = new HashMap<>();\r\n    }\r\n\r\n    public static ActorCatalog getmyActorCatalog() {\r\n        if (myActorCatalog == null) {\r\n            myActorCatalog = new ActorCatalog();\r\n        }\r\n        return myActorCatalog;\r\n    }\r\n\r\n    public HashMap<String, Actor> getActorL() {\r\n        return this.actorL;\r\n    }\r\n\r\n    private boolean exist(String pActorName, String pActorSurname) {\r\n        return actorL.get(pActorName + \" \" + pActorSurname) != null;\r\n    }\r\n\r\n    public void addActor(Actor pActor) {\r\n        if (!this.exist(pActor.getName(), pActor.getSurname())) {\r\n            this.actorL.put(pActor.getName() + \" \" + pActor.getSurname(), pActor);\r\n        }\r\n    }\r\n\r\n    public Actor searchActor(Actor pActor) {\r\n        if (this.exist(pActor.getName(), pActor.getSurname())) {\r\n            return this.actorL.get(pActor.getName() + \" \" + pActor.getSurname());\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public void removeActor(Actor pActor) {\r\n        if (this.exist(pActor.getName(), pActor.getSurname())) {\r\n            this.actorL.remove(pActor.getName() + \" \" + pActor.getSurname());\r\n            System.out.println(\"Actor erased\");\r\n        } else {\r\n            System.out.println(\"Actor not found\");\r\n        }\r\n    }\r\n\r\n    public String[] quickSortList() {\r\n        String[] auxS = new String[actorL.size()];\r\n        int i = 0;\r\n        for (String key : actorL.keySet()) {\r\n            auxS[i] = key;\r\n            i++;\r\n        }\r\n        StringQuickSort.sort(auxS);\r\n        return auxS;\r\n    }\r\n\r\n    public void printList(String[] auxS) {\r\n        for (String key : auxS) {\r\n            System.out.println(key);\r\n        }\r\n    }\r\n\r\n    public int getSize(){\r\n        return this.actorL.size();\r\n    }\r\n\r\n    public int getTotalFilms(){\r\n        int cont = 0;\r\n        for (String key : this.actorL.keySet()){\r\n            cont += this.actorL.get(key).getFilmList().getTotalFilms();\r\n        }\r\n        return cont;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 5.3 Clase ActorList (Implementación de UnorderedCircularLinkedList)\r\n\r\n``` java\r\npackage lab2;\r\n\r\n\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * Created by david on 25/09/2016.\r\n */\r\npublic class ActorList {\r\n\r\n    private UnorderedCircularLinkedList<Actor> actorList;\r\n\r\n\r\n    public ActorList() {\r\n        this.actorList = new UnorderedCircularLinkedList<>();\r\n    }\r\n\r\n\r\n    public boolean exist(String pActorName, String pActorSurname) {\r\n        return this.actorList.contains(new Actor(pActorName, pActorSurname));\r\n    }\r\n\r\n    public void addActor(Actor auxActor) {\r\n        if (!this.exist(auxActor.getName(), auxActor.getSurname())) {\r\n            this.actorList.addToRear(auxActor);\r\n        }\r\n    }\r\n\r\n    public Actor getActor(String pActorName, String pActorSurname) {\r\n        if (this.exist(pActorName , pActorSurname)) {\r\n            return actorList.find(new Actor(pActorName,pActorSurname));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public void removeActor(Actor pActor) {\r\n        if (this.exist(pActor.getName(), pActor.getSurname())) {\r\n            this.actorList.remove(new Actor(pActor.getName() , pActor.getSurname()));\r\n        }\r\n    }\r\n\r\n    public void printActors() {\r\n        System.out.println(\"These are all the actors: \");\r\n        Iterator<Actor> itr = this.actorList.iterator();\r\n\r\n        if (this.actorList.isEmpty()) {\r\n            System.err.println(\" No consta ningun actor\");\r\n        } else {\r\n            while (itr.hasNext()) {\r\n                Actor act = itr.next();\r\n                System.out.println(act.getName()+\" \"+act.getSurname());\r\n            }\r\n        }\r\n    }\r\n\r\n    public int getActorsNumber(){\r\n        return this.actorList.count;\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n### 5.4 Clase CircularLinkedList\r\n\r\n```java\r\npackage lab2;\r\n\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * @author Josu on 27/10/2016\r\n */\r\npublic class CircularLinkedList<T> implements ListADT<T> {\r\n\r\n    // Atributos\r\n    protected Node<T> first;\r\n    protected Node<T> last; // apuntador al ultimo\r\n    protected String descr;  // descripci�n\r\n    protected int count;\r\n\r\n    // Constructor\r\n    public CircularLinkedList() {\r\n        last = null;\r\n        descr = \"\";\r\n        count = 0;\r\n    }\r\n\r\n    public void setDescr(String nom) {\r\n        descr = nom;\r\n    }\r\n\r\n    public String getDescr() {\r\n        return descr;\r\n    }\r\n\r\n    public T removeFirst() {\r\n        // Elimina el primer elemento de la lista\r\n        // Precondici�n: la lista tiene al menos un elemento\r\n        // COMPLETAR EL CODIGO Y CALCULAR EL COSTE\r\n\r\n        // Elimina el primer elemento de la lista\r\n        // Precondici�n: la lista tiene al menos un elemento\r\n        // COMPLETAR EL CODIGO Y CALCULAR EL COSTE\r\n\r\n        Node<T> first = last.next;\r\n        if (size() == 1) {\r\n            last = null;\r\n        } else {\r\n            last.next = last.next.next;\r\n        }\r\n        count--;\r\n        return first.data;\r\n    }\r\n\r\n    public T removeLast() {\r\n        // Elimina el �ltimo elemento de la lista\r\n        // Precondici�n: la lista tiene al menos un elemento\r\n        // COMPLETAR EL CODIGO Y CALCULAR EL COSTE\r\n        Node<T> pLast = last;\r\n        if (size() == 1) {\r\n            last = null;\r\n        } else {\r\n            Node<T> current = last.next;\r\n            while (current.next != last) {\r\n                current = current.next;\r\n            }\r\n            last = current;\r\n            last.next = last.next.next;\r\n        }\r\n        count--;\r\n        return pLast.data;\r\n    }\r\n\r\n    /*\r\n    pre: tenemos una lista de elementos. es posible que la lista es vacia.\r\n    post: tenemos una lista de elementos a la que le hemos eliminado el elemento que recibimos en caso de que este eista previamente\r\n     */\r\n    public T remove(T elem) {\r\n        Node<T> current = last;\r\n        int i = 0;\r\n        T returnNum;\r\n\r\n        if (this.isEmpty()){ return null;} //if its empty we return null\r\n        else{//if not null\r\n            while(!current.next.data.equals(elem) && i!=size()){//goes out when finds the element or overpass the size\r\n                current = current.next;\r\n                i++;\r\n            }\r\n            if (i==count){//if the elemente isn't finded\r\n                System.out.println(\"The element isn't finded\");\r\n                return null;\r\n            }else{//we find it. we have to remove currents pointing node\r\n                if (count == 1){//if we only have one element\r\n                    returnNum = last.data;\r\n                    last = null;\r\n                }else{//if are more elements than 1\r\n                    returnNum = current.next.data;\r\n\r\n                    if (current.next == last) {\r\n                        last = current;//if the element is the last we dont lose the pointer, we give it to the previous item\r\n                    }\r\n                    current.next = current.next.next;\r\n                }\r\n                count--;\r\n                System.out.println(\"\\n ->  \"+elem+\" it's been deleted\");\r\n                return returnNum;\r\n            }\r\n        }\r\n    }\r\n\r\n    public T first() {\r\n        //Da acceso al primer elemento de la lista\r\n        if (isEmpty())\r\n            return null;\r\n        else return last.next.data;\r\n    }\r\n\r\n    public T last() {\r\n        //Da acceso al �ltimo elemento de la lista\r\n        if (isEmpty())\r\n            return null;\r\n        else return last.data;\r\n    }\r\n\r\n    public boolean contains(T elem) {\r\n        if (isEmpty()) {\r\n            return false;\r\n        }\r\n\r\n        Node<T> current = last.next; // Empieza con el primer elemento\r\n\r\n        while ((current != last) && !elem.equals(current.data))\r\n            current = current.next;\r\n        return elem.equals(current.data);\r\n    }\r\n\r\n    public T find(T elem) {\r\n        //Determina si la lista contiene un elemento concreto, y develve su referencia, null en caso de que no est�\r\n        // COMPLETAR EL CODIGO Y CALCULAR EL COSTE\r\n        Integer i = 0;\r\n        T returnNum;\r\n        Node<T> current = last;\r\n\r\n        if(this.isEmpty()){\r\n            return null;\r\n        }\r\n        else{//si hay elementos, buscamos nuestro elemento\r\n            while(!current.data.equals(elem) && i!=size()){//tiene que salir si recorre todos los elementos\r\n                current = current.next;\r\n                i++;\r\n            }\r\n            if(i==count){//no lo ha encontrado\r\n                return null;\r\n            }\r\n            else{//lo a encontrado\r\n                returnNum = current.data;\r\n                return returnNum;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return last == null;\r\n    }\r\n\r\n    //Determina el n�mero de elementos de la lista\r\n    public int size() {\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Return an iterator to the stack that iterates through the items .\r\n     */\r\n    public Iterator<T> iterator() {\r\n        return new ListIterator();\r\n    }\r\n\r\n    // an iterator, doesn't implement remove() since it's optional\r\n    private class ListIterator implements Iterator<T> {\r\n\r\n        private Node<T> current;\r\n        private int cont;\r\n\r\n        public ListIterator(){\r\n            current = last.next;\r\n            cont = count;\r\n        }\r\n\r\n        public boolean hasNext(){\r\n            boolean a = cont==0?false:true;\r\n            return a;\r\n        }\r\n\r\n        public T next(){\r\n            T content = null;\r\n            if (current != null) {\r\n                content = current.data;\r\n                current = current.next;\r\n                cont--; //mover al metdo next\r\n            }\r\n            return content;\r\n        }\r\n\r\n    }\r\n\r\n    public void visualizarNodos() {\r\n        System.out.print(this.toString()+\" \");\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        String result = new String();\r\n        Iterator<T> it = iterator();\r\n        while (it.hasNext()) {\r\n            T elem = it.next();\r\n            result = result + \"[\" + elem.toString() + \"] \\n\";\r\n        }\r\n        return \"SimpleLinkedList \" + result + \"]\";\r\n    }\r\n}\r\n```\r\n\r\n### 5.5 Clase FileManager (El método de exportación ha sufrido cambios)\r\n\r\n```java\r\npackage lab2;\r\n\r\nimport java.io.*;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\n\r\n/**\r\n * Created by david on 25/09/2016.\r\n */\r\npublic class FileManager {\r\n\r\n    private static FileManager myFileManager;\r\n\r\n    private FileManager() {\r\n    }\r\n\r\n    public static FileManager getMyFileManager() {\r\n        if (myFileManager == null) {\r\n            myFileManager = new FileManager();\r\n        }\r\n        return myFileManager;\r\n    }\r\n\r\n    public static int countLines(File pFile) throws IOException {\r\n        LineNumberReader lnr = new LineNumberReader(new FileReader(pFile));\r\n        lnr.skip(Long.MAX_VALUE);\r\n        lnr.close();\r\n        return lnr.getLineNumber() + 1;//Add 1 because line index starts at 0\r\n    }\r\n\r\n\r\n    public void readFile(int pOption) throws IOException {\r\n\r\n        String[] auxLine1;\r\n\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        int j = 0; //j= counts the actual line of file\r\n        int total = 0; //total = saves total running time of reading\r\n        int auxCont = 0;  //auxCount = saves the percentage of reading of file\r\n\r\n        try (InputStream resource = FileManager.class.getResourceAsStream(\"testAllActors.txt\")) {\r\n\r\n            int contLines = countLines(new File(\"/Users/Josu/IdeaProjects/EDA16-17/src/lab2/testAllActors.txt\"));\r\n\r\n            String filmName, actorName, actorSurname;\r\n\r\n            String[] auxLine2;\r\n\r\n            Film auxFilm;\r\n\r\n            List<String> lines = new BufferedReader(new InputStreamReader(resource, StandardCharsets.UTF_8)).lines().collect(Collectors.toList());\r\n\r\n            for (String line : lines) {\r\n\r\n                auxLine1 = line.split(\"\\\\s+\\\\--->+\\\\s\"); //we split to get the name of the movie\r\n\r\n                if (pOption == 1) {\r\n                    NormalizeStrings.getMyNormalizeString().run(auxLine1);\r\n                }\r\n\r\n                filmName = auxLine1[0]; //here we save the name of the film\r\n\r\n                auxLine2 = auxLine1[1].split(\"\\\\s+\\\\&&&+\\\\s\"); //we split the array of actors in\r\n\r\n                auxFilm = new Film(filmName); //create a new film\r\n\r\n                if (pOption == 1) {\r\n                    if (!auxFilm.getName().contains(\"�\")) {\r\n                        FilmCatalog.getMyFilmCatalog().addFilm(auxFilm); //we add the film if its not been added before\r\n                    }\r\n                } else {\r\n                    FilmCatalog.getMyFilmCatalog().addFilm(auxFilm); //we add the film if its not been added before\r\n                }\r\n\r\n                int i = 0;\r\n\r\n                while (auxLine2.length > i) { // mientras el indice no sea mayor que el tamaño de la lista(indexOutOfBoundException)\r\n\r\n                    actorSurname = \"\";\r\n                    actorName = auxLine2[i];\r\n\r\n                    if (actorName.contains(\"(\")) {\r\n                        auxLine1 = actorName.split(\"\\\\s\\\\(\");\r\n                        actorName = auxLine1[0];\r\n                    }\r\n                    if (actorName.contains(\",\")) {//convertimos -> Apellido, Nombre --> Nombre, Apellido (como es habitual)\r\n                        auxLine1 = actorName.split(\",\\\\s*\");\r\n                        if (auxLine1.length > 1) {\r\n                            if (auxLine1[1].compareToIgnoreCase(\"null\") != 0) {\r\n                                actorSurname = auxLine1[0];\r\n                                actorName = auxLine1[1];\r\n                            } else {\r\n                                actorName = auxLine1[0];\r\n                            }\r\n                        }\r\n                    }\r\n                    Actor auxActor = new Actor(actorName, actorSurname);//Creamos la pelicula enviandole el nombre una vez normalizado\r\n\r\n                    if (pOption == 1) {\r\n                        if (!auxActor.getName().contains(\"�\")) {\r\n                            if (auxActor.getName().charAt(0) > 'A' && auxActor.getName().charAt(0) < 'Z') {\r\n                                auxActor.getFilmList().addFilm(auxFilm);\r\n                                ActorCatalog.getmyActorCatalog().addActor(auxActor);\r\n                                if (!auxFilm.getName().contains(\"�\")) {\r\n                                    FilmCatalog.getMyFilmCatalog().getFilm(auxFilm.getName()).getActorList().addActor(auxActor);\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        auxActor.getFilmList().addFilm(auxFilm);\r\n                        ActorCatalog.getmyActorCatalog().addActor(auxActor);\r\n                        FilmCatalog.getMyFilmCatalog().getFilm(auxFilm.getName()).getActorList().addActor(auxActor);\r\n                    }\r\n\r\n                    i++;\r\n\r\n                }\r\n                if (j == 0) {\r\n                    System.out.println(\"\\t[*] 0% file readed\");\r\n                }\r\n                j++;\r\n\r\n                if (((j * 100) / contLines) % 5 == 0) {\r\n                    if (((j * 100) / contLines) != auxCont) {\r\n                        auxCont = ((j * 100) / contLines);\r\n                        long stopTime = System.currentTimeMillis();\r\n                        total = (int) (stopTime - startTime) / 1000;\r\n\r\n                        System.out.println(\"\\t[*] \" + auxCont + \"% file readed. Time elapsed: \" + total + \"s\");\r\n                    }\r\n                } else if (((j * 100) / contLines) % 5 == 0) {\r\n                    SwingGUI.getMyJMenu().updateBar((j * 100) / contLines);\r\n                }\r\n            }\r\n            System.out.println(\"\\t[*] 100% file readed. Time elapsed: \" + total + \"s\");\r\n        }\r\n        System.out.println(\"\\t-------- File read finished --------\\n\");\r\n        System.out.println(\"\\t--- Elapsed time to read the file ---> \" + total + \"s---\");\r\n\r\n        System.out.println(\"\\t--- Total actor/actresses found :\" + ActorCatalog.getmyActorCatalog().getActorL().size()+\" ---\");\r\n        System.out.println(\"\\t--- Total films found : \" + FilmCatalog.getMyFilmCatalog().getSize()+\" ---\");\r\n\r\n        float avActorsFilm = (float)FilmCatalog.getMyFilmCatalog().getTotalActors()/(float)FilmCatalog.getMyFilmCatalog().getSize();\r\n        System.out.printf(\"\\t--- Average actors per film: %.2f\",avActorsFilm);\r\n        double avFilmsActor = (double)ActorCatalog.getmyActorCatalog().getTotalFilms()/(double)ActorCatalog.getmyActorCatalog().getSize();\r\n        System.out.print(\"---\\n\");\r\n        System.out.printf(\"\\t--- Average films per actor: %.2f\", avFilmsActor);\r\n        System.out.print(\"---\\n\");\r\n\r\n    }\r\n\r\n   @SuppressWarnings(\"rawtypes\")\r\n    public void exportToFile() {\r\n\r\n        String[] keys = ActorCatalog.getmyActorCatalog().quickSortList();\r\n\r\n        FileWriter fichero = null;\r\n        PrintWriter pw;\r\n\r\n        long timeStart = System.currentTimeMillis();\r\n\r\n        try {\r\n            String directorio = System.getProperty(\"user.dir\");//cogemos variable entorno\r\n            fichero = new FileWriter(directorio + \"/ActorList_ordered.txt\");\r\n            pw = new PrintWriter(fichero);\r\n\r\n            int i = 1;\r\n            for (int i1 = 0, keysLength = keys.length; i1 < keysLength; i1++) {\r\n                Object key = keys[i1];\r\n                pw.print(\"Actor \" + i + \" -> \");\r\n                pw.println(ActorCatalog.getmyActorCatalog().getActorL().get(key).getName() + \" \" + ActorCatalog.getmyActorCatalog().getActorL().get(key).getSurname());\r\n                Object[] keys2;\r\n                Iterator<Film> itr = ActorCatalog.getmyActorCatalog().getActorL().get(key).getFilmList().getIterator();\r\n                while (itr.hasNext()) {\r\n                    Film auxFilm = itr.next();\r\n                    pw.println(\"\\t\" + ActorCatalog.getmyActorCatalog().getActorL().get(key).getFilmList().getFilmL().find(auxFilm).getName());\r\n                }\r\n                i++;\r\n                int percentage = (i * 100) / ActorCatalog.getmyActorCatalog().getActorL().size();\r\n                if (((i * 100) / ActorCatalog.getmyActorCatalog().getActorL().size()) % 5 == 0) {\r\n                    if (((i * 100) / ActorCatalog.getmyActorCatalog().getActorL().size()) != percentage) {\r\n                        System.out.println(\"\\t\\t[*] \" + percentage + \"%\");\r\n                    }\r\n                }\r\n\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                if (null != fichero) {\r\n                    fichero.close();\r\n                }\r\n                long timeTotal = (System.currentTimeMillis() - timeStart);\r\n                System.out.println(\"\\t\\t --- Elapsed time to export the file --- : \" + (int) timeTotal / 1000 + \"sec, \" + timeTotal * 1000 + \"ms\\n\");\r\n                System.out.println(\"\\n\\tFile exported to: \" + System.getProperty(\"user.dir\"));\r\n            } catch (Exception e2) {\r\n                e2.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 5.6 Clase Film (implementada interfaz Comparable<T>)\r\n\r\n```java\r\npackage lab2;\r\n\r\n/**\r\n * Created by david on 25/09/2016.\r\n */\r\npublic class Film implements Comparable<Film> {\r\n\r\n    private String name;\r\n    private int earned = 0;\r\n    private ActorList actorList;\r\n\r\n    public Film(String pName) {\r\n        this.name = pName;\r\n        this.actorList = new ActorList();\r\n    }\r\n\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    public int getEarned() {\r\n        return this.earned;\r\n    }\r\n\r\n    public void incrementEarned(int auxEarned) {\r\n        this.earned += auxEarned;\r\n    }\r\n\r\n    public ActorList getActorList() {\r\n        return this.actorList;\r\n    }\r\n\r\n\r\n    @Override\r\n    public int compareTo(Film pFilm) {\r\n        return this.getName().compareToIgnoreCase(pFilm.getName());\r\n    }\r\n}\r\n```\r\n\r\n### 5.7 Clase FilmCatalog \r\n\r\n```java\r\npackage lab2;\r\n\r\nimport java.util.HashMap;\r\n\r\n/**\r\n * Created by Josu on 25/09/2016.\r\n */\r\npublic class FilmCatalog {\r\n\r\n    private static FilmCatalog myFilmCatalog;\r\n    private HashMap<String, Film> filmL;\r\n\r\n    private FilmCatalog() {\r\n        this.filmL = new HashMap<>();\r\n    }\r\n\r\n    public static FilmCatalog getMyFilmCatalog() {\r\n        if (myFilmCatalog == null) {\r\n            myFilmCatalog = new FilmCatalog();\r\n        }\r\n        return myFilmCatalog;\r\n    }\r\n\r\n    public boolean exist(String pFilmName) {\r\n        return filmL.get(pFilmName) != null;\r\n    }\r\n\r\n    public void addFilm(Film pFilm) {\r\n        if (!this.exist(pFilm.getName())) {\r\n            this.filmL.put(pFilm.getName(), pFilm);\r\n        }\r\n    }\r\n\r\n    public Film getFilm(String pFilmName) {\r\n        if (this.exist(pFilmName)) {\r\n            return this.filmL.get(pFilmName);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public int getSize(){\r\n        return this.filmL.size();\r\n    }\r\n\r\n    public int getTotalActors(){\r\n        int cont = 0;\r\n        for (String key : filmL.keySet()){\r\n            cont += this.filmL.get(key).getActorList().getActorsNumber();\r\n        }\r\n        return cont;\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 5.8 Clase FilmList (Implementación de OrderedCircularLinkedList)\r\n\r\n```java\r\npackage lab2;\r\n\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * Created by Josu on 25/09/2016.\r\n */\r\npublic class FilmList {\r\n\r\n    private OrderedCircularLinkedList<Film> filmL;\r\n\r\n    public FilmList() {\r\n        this.filmL = new OrderedCircularLinkedList<>();\r\n    }\r\n\r\n    public Iterator<Film> getIterator(){ return this.filmL.iterator();}\r\n\r\n    private boolean exist(String pFilmName) {\r\n        return this.filmL.contains(new Film(pFilmName));\r\n    }\r\n\r\n    public void addFilm(Film pFilm) {\r\n        if (!this.exist(pFilm.getName())) {\r\n            this.filmL.add(pFilm);\r\n        }\r\n    }\r\n\r\n    public Film getFilm(String pFilmName) {\r\n        if (this.exist(pFilmName)) {\r\n            return this.filmL.find(new Film(pFilmName));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public OrderedCircularLinkedList<Film> getFilmL() {\r\n        return this.filmL;\r\n    }\r\n\r\n    public void printFilms() {\r\n        System.out.println(\"These are all the films: \");\r\n        Iterator<Film> itr = this.filmL.iterator();\r\n\r\n        if (this.filmL.isEmpty()) {\r\n            System.err.println(\" No consta ningun actor para esta pelicula\");\r\n        } else {\r\n            while (itr.hasNext()) {\r\n                Film film = itr.next();\r\n                System.out.println(film.getName());\r\n            }\r\n        }\r\n    }\r\n\r\n    public int getTotalFilms(){\r\n        return this.filmL.count;\r\n    }\r\n}\r\n```\r\n\r\n### 5.9 Clase OrderedCircularLinkedList\r\n\r\n```java\r\n\r\n/**\r\n * Created by Josu on 24/10/2016.\r\n */\r\npackage lab2;\r\n\r\npublic class OrderedCircularLinkedList<T extends Comparable<T>> extends CircularLinkedList<T> implements OrderedListADT<T> {\r\n\r\n    public void add(T elem) {\r\n        Node<T> current;    //pointer\r\n        Node<T> auxNode = new Node<T>(elem); //auxiliar pointer\r\n        boolean finded = false; //flag for while\r\n\r\n        if (count == 0 ? true : false) {//if it's empty\r\n            last = auxNode;\r\n            auxNode.next = auxNode;\r\n        } else {\r\n            current = last.next;//first element\r\n            if (current.data.compareTo(elem) > 0) {//if the first is > elem\r\n                auxNode.next = last.next;\r\n                last.next = auxNode;\r\n\r\n            } else if (last.data.compareTo(elem) < 0) {//if the last < auxNode\r\n                auxNode.next = last.next;\r\n                last.next = auxNode;\r\n                last = auxNode;\r\n            } else { //between two elements\r\n                while (!finded) {\r\n                    if (current.data.compareTo(elem) < 0 && current.next.data.compareTo(elem) > 0) { //if whe've finded where to insert\r\n                        auxNode.next = current.next;\r\n                        current.next = auxNode;\r\n                        finded = true;\r\n                    }\r\n                    current = current.next;\r\n                }\r\n            }\r\n        }\r\n        count++;\r\n    }\r\n}\r\n```\r\n\r\n### 5.10 Clase StringQuickSort\r\n\r\n```java\r\npackage lab1;\r\n\r\n/**\r\n * Created by David on 24/10/2016.\r\n */\r\npublic class StringQuickSort {\r\n\r\n\r\n    public static void quickSort(String[] table){\r\n        quickSort(table, 0, table.length-1);\r\n    }\r\n\r\n    private static void quickSort(String[] table, int start, int end){\r\n        if(end-start > 0){\r\n            int partitionIndex = partition(table, start, end);\r\n            quickSort(table, start, partitionIndex-1);\r\n            quickSort(table, partitionIndex + 1, end);\r\n        }\r\n    }\r\n\r\n    private static int partition(String[] table, int s, int e){\r\n        String pivote = table[s];\r\n        int left = s;\r\n        int right = e;\r\n\r\n        while(left < right){\r\n            while(table[left].compareTo(pivote) <= 0 &&  left<right){\r\n                left++;\r\n            }\r\n            while(table[right].compareTo(pivote) > 0){\r\n                right--;\r\n            }\r\n            if(left < right){\r\n                swap(table, left, right);\r\n            }\r\n        }\r\n        table[s]=table[right];\r\n        table[right] = pivote;\r\n\r\n        return right;\r\n    }\r\n\r\n    public static void swap(String[] table, int l, int r){\r\n        String temp = table[l];\r\n        table[l] = table[r];\r\n        table[r] = temp;\r\n    }\r\n```\r\n\r\n### 5.11 Clase TerminalUI\r\n\r\n```java\r\npackage lab2;\r\n\r\nimport java.io.*;\r\nimport java.util.Scanner;\r\n\r\n/**\r\n * Created by Josu on 26/09/2016.\r\n */\r\npublic class TerminalUI {\r\n\r\n    private static TerminalUI myTerminalGUI;\r\n    private Scanner optMenu;\r\n\r\n    private TerminalUI() {\r\n        optMenu = new Scanner(System.in);\r\n    }\r\n\r\n    public static TerminalUI getMyTerminalGUI() {\r\n        if (myTerminalGUI == null) {\r\n            myTerminalGUI = new TerminalUI();\r\n        }\r\n        return myTerminalGUI;\r\n    }\r\n\r\n    public static void main() throws FileNotFoundException {\r\n\r\n        String[] auxActorArray;\r\n        String auxActorName;\r\n        String auxActorSurname;\r\n\r\n        String auxS;\r\n\r\n        System.out.println(\"\\t\\t\\t***-----Welcome to our IMDb EDA16/17 project menu-----***\");\r\n\r\n        System.out.println(\"\\n\\n ** We use OrderedCircularLinkedList for the list of films per actor, for the list of\");\r\n        System.out.println(\"actors per film we decide to use UnorderedCircularLinkedList. ActorCatalog and FilmCatalog\");\r\n        System.out.println(\"are still using HashMap<String,Actor> and HashMap<String,Film> respectively **\");\r\n\r\n        do {\r\n            System.out.println(\"\\n\\t\\t\\t----------MENU----------\");\r\n            System.out.println(\"\\t\\t1) Read data from file\");\r\n            System.out.println(\"\\t\\t2) Search for an actor/actress\");\r\n            System.out.println(\"\\t\\t3) Add a new actor/actress\");\r\n            System.out.println(\"\\t\\t4) Search for films of a particular actor\");\r\n            System.out.println(\"\\t\\t5) Search for actor of a particular film\");\r\n            System.out.println(\"\\t\\t6) Increase the money raised by a film\");\r\n            System.out.println(\"\\t\\t7) Erase an actor/actress\");\r\n            System.out.println(\"\\t\\t8) Obtain an ordered list of actor (name,surname)\");\r\n            System.out.println(\"\\t\\t9) Save/Export the new list to a file\");\r\n\r\n            int optMenu = Keyboard.getMyKeyboard().getInt();\r\n\r\n            switch (optMenu) {\r\n                case 0:\r\n                    System.out.println(\"\\t\\t--- Saliendo del programa... ----\");\r\n                    break;\r\n                case 1:\r\n                    try {\r\n                        System.out.println(\"\\tSelect one of options below: \");\r\n                        System.out.println(\"\\t\\t1) Read only the 'readable' actors/films (after trying to rescue some names from the codification, take only the 'full readables') \");\r\n                        System.out.println(\"\\t\\t2) Read the full list of actors/movies (don't care if they're wrong written, after running our conversor\");\r\n                        int optMenu1 = 0;\r\n                        while (optMenu1 < 1 || optMenu1 > 2) {\r\n                            optMenu1 = Keyboard.getMyKeyboard().getInt();\r\n                            if (optMenu1 == 1) {\r\n                                FileManager.getMyFileManager().readFile(1);\r\n                            } else if (optMenu1 == 2) {\r\n                                FileManager.getMyFileManager().readFile(2);\r\n                            } else {\r\n                                System.out.println(\"Invalid option, try again. Select a number between 1-2 range\");\r\n                            }\r\n                        }\r\n\r\n                    } catch (FileNotFoundException e1) {\r\n                        System.out.println(\"File not found. ¿Are you sure that you're opening the correct file?\");\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    System.out.println(\"Enter the name of the actor you want to look for: \");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    auxActorArray = auxS.split(\"\\\\s\");\r\n                    auxActorName = auxActorArray[0];\r\n                    auxActorSurname = auxActorArray[1];\r\n                    Actor auxA = ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname));\r\n                    if (auxA == null) {\r\n                        System.out.println(\"Actor not finded: \" + auxS);\r\n                    } else {\r\n                        System.out.println(\"Actor finded: \" + auxA.getName());\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    System.out.println(\"Enter the name of the actor that you want to add: \");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    auxActorArray = auxS.split(\"\\\\s\");\r\n                    auxActorName = auxActorArray[0];\r\n                    auxActorSurname = auxActorArray[1];\r\n                    if (ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)) != null) {\r\n                        System.out.println(\"Actor: \" + auxS + \" already exist\");\r\n                    } else {\r\n                        ActorCatalog.getmyActorCatalog().addActor(new Actor(auxActorName, auxActorSurname));\r\n                        System.out.println(\"Actor: \" + auxS + \" added to the ActorCatalog\");\r\n                    }\r\n                    break;\r\n                case 4:\r\n                    System.out.println(\"Enter the name of the actor whose films you want to know\");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    auxActorArray = auxS.split(\"\\\\s\");\r\n                    auxActorName = auxActorArray[0];\r\n                    auxActorSurname = auxActorArray[1];\r\n                    if (ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)) != null) {\r\n                        ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)).getFilmList().printFilms();\r\n                    } else {\r\n                        System.out.println(\"Actor: \" + auxS + \" do not exist in the ActorCatalog\");\r\n                    }\r\n                    break;\r\n                case 5:\r\n                    System.out.println(\"Enter the film whose actors that do you want to know: \");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    if (FilmCatalog.getMyFilmCatalog().getFilm(auxS) != null) {\r\n                        FilmCatalog.getMyFilmCatalog().getFilm(auxS).getActorList().printActors();\r\n                    }\r\n                    break;\r\n                case 6:\r\n                    System.out.println(\"Enter the film whose amount of earning you want to raise: \");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    System.out.println(\"Enter the amount of money that you want to increase: \");\r\n                    int auxI = Keyboard.getMyKeyboard().getInt();\r\n                    if (FilmCatalog.getMyFilmCatalog().exist(auxS)) {\r\n                        FilmCatalog.getMyFilmCatalog().getFilm(auxS).incrementEarned(auxI);\r\n                        System.out.println(\"Total earned by the film: \" + FilmCatalog.getMyFilmCatalog().getFilm(auxS).getEarned());\r\n                    } else {\r\n                        System.out.println(\"File not found. Are you sure that you have written title correctly?\");\r\n                    }\r\n                    break;\r\n                case 7:\r\n                    System.out.println(\"Enter the name of the actor that you want to remove\");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    auxActorArray = auxS.split(\"\\\\s\");\r\n                    auxActorName = auxActorArray[0];\r\n                    auxActorSurname = auxActorArray[1];\r\n                    if (ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)) != null) {\r\n                        ActorCatalog.getmyActorCatalog().removeActor(new Actor(auxActorName, auxActorSurname));\r\n                        System.out.println(\"Actor: \" + auxS + \" succesfully removed\");\r\n                    } else {\r\n                        System.out.println(\"Actor: \" + auxS + \" do not exist in the ActorCatalog\");\r\n                    }\r\n                    break;\r\n                case 8:\r\n                    System.out.println(\"Do you want to print (console) the ordered list of actors?\");\r\n                    if (Keyboard.getMyKeyboard().getString().equalsIgnoreCase(\"y\")){\r\n                        ActorCatalog.getmyActorCatalog().printList(ActorCatalog.getmyActorCatalog().quickSortList());\r\n                    break;\r\n                    }\r\n                        ActorCatalog.getmyActorCatalog().quickSortList();\r\n                    break;\r\n                case 9:\r\n                    FileManager.getMyFileManager().exportToFile();\r\n                    break;\r\n            }\r\n        } while (1 != 0);\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 5.12 UnorderedCircularLinkedList\r\n\r\n```java\r\npackage lab2;\r\n\r\n/**\r\n * @author Josu on 27/10/2016\r\n * @author David on 27/10/2016\r\n */\r\npublic class UnorderedCircularLinkedList<T> extends CircularLinkedList<T> implements UnorderedListADT<T> {\r\n\r\n    /*Pre: We have a list, empty or not\r\n    * Post: We have added the element to the first position of the list*/\r\n\tpublic void addToFront(T elem){\r\n        //System.out.println(\"AÑADIMOS el elemento \"+elem+\" a la PRIMERA POSICION de la lista\");\r\n\r\n        Node<T> newNode = new Node<T>(elem);\r\n\t\tif(isEmpty()){\r\n\t\t\tlast = newNode;\r\n            last.next = last;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tnewNode.next = last.next;\r\n\t\t\tlast.next = newNode;\r\n\t\t}\r\n\t\tcount++;\r\n\t}\r\n\r\n    /* Pre: We have a list, empty or not\r\n    *  Post: We've added the element to the last position*/\r\n\tpublic void addToRear(T elem) {\r\n        //System.out.println(\"AÑADIMOS el elemento \"+elem+\" a la ULTIMA POSICION de la lista\");\r\n\r\n\t\tNode<T> newNode = new Node<T>(elem);\r\n\t\tif(isEmpty()){\r\n\t\t\tlast = newNode;\r\n\t\t\tlast.next = last;\r\n\t\t}else{\r\n\t\t\tnewNode.next = last.next; //the next of 'our' rear points firts\r\n\t\t\tlast.next = newNode; //the next of the previous last points our 'rear' node\r\n\t\t\tlast = newNode;\r\n\t\t}\r\n\t\tcount++;\r\n\t}\r\n\t/* Pre: We have a list, we must have at least one element. We receive the element that we want to add and the target to add after\r\n\t * Post: We have added our element after the target element of the list */\r\n\tpublic void addAfter(T elem, T target) {\r\n\r\n        //System.out.println(\"Añadimos el elemento \"+elem+\" tras el elemento \"+target+\"\\n\");\r\n\r\n        Node<T> newNode = new Node<T>(elem);\r\n\t\tNode<T> current = last;\r\n\r\n\t\twhile(!current.data.equals(target)){\r\n\t\t\tcurrent = current.next;\r\n\t\t}\r\n\r\n\t\tnewNode.next = current.next;\r\n\t\tcurrent.next = newNode;\r\n\r\n\t\tcount++;\r\n\r\n\t}\r\n\r\n}\r\n```\r\n\r\n## 6. Resultados de las pruebas\r\n\r\n**Estos son los resultados de las pruebas**, en la etapa final de desarrollo (lo que estamos entregando) de la actividad. **Todos los tiempos que mostramos son medias** realizadas (entre 5-10 ejecuciones) **de la misma operación**. Las pruebas **se han realizado en diferentes equipos con diferentes sistemas operativos**, detallamos:\r\n\r\nEn el fichero normalizado encontramos **1 061 522** actores, **230 369** peliculas.\r\nEn el fichero sin normalizar (cogiento toda la informacion, independientemente de si estan bien escritos) encontramos **1 191 316** actores, **238 809** peliculas.\r\n\r\n\t- Media de actores por pelicula\r\n\t\t* 11,91 actores en el fichero normalizado\r\n\t\t* 13,78 actores en el fichero sin normalizar\r\n\t- Media de peliculas por actor**: 1.0 en ambas pruebas (fichero normalizado y no normalizado)\r\n\r\n- **CPU**: Intel i5 6600K 3,9 GHz x 4 cores, **GPU:** nVidia GTX 970 4GB Strix,**RAM:** 16GB DDR5  2666, **SO:** *Windows 10 Pro x64*\r\n\t- Cargar fichero normalizado: 7sec (4s menos que el lab1)\r\n\t- Cargar fichero completo: 8sec (3s menos que el lab1)\r\n\t- Ordenar lista normalizada de actores: 0sec, 609000ms\r\n\t- Ordenar lista completa de actores: 0sec, 688000ms\r\n\t- Exportar lista normalizada de actores: 1sec, 1282000ms\r\n\t- Exportar lista completa de actores: 1sec, 1672000ms\r\n\r\n- **CPU**: Intel i5 2,7 GHz x 2 cores, **GPU:** HD 6100,**RAM:** 8GB LPDDR3  1866, **SO:** *Mac OS Sierra (10.12)*\r\n\t- Cargar fichero normalizado: 16sec (4s menos que el lab1)\r\n\t- Cargar fichero completo: 18sec (8s menos que el lab1)\r\n\t- Ordenar lista normalizada de actores: 1sec, 1398000ms\r\n\t- Ordenar lista completa de actores: 1sec, 1376000ms\r\n\t- Exportar lista normalizada de actores: 4sec, 12976000ms (8s menos que el lab1)\r\n\t- Exportar lista completa de actores: 9sec, 21158000ms (12s menos que el lab1)\r\n\r\n- **CPU**: Intel Atom Z3775 1,46 GHz x 2 cores, **GPU:** Intel HD Graphics (Bay Trail) (311 - 778 MHz),**RAM:** 2GB RAM 1333, **SO:** *Windows 10 Home x32*\r\n\t- Cargar fichero normalizado: 68sec\r\n\t- Cargar fichero completo: El ordenador no es capaz de leerlo\r\n\t- Ordenar lista normalizada de actores: 2sec, 2312000ms\r\n\t- Ordenar lista completa de actores: No es capaz de leer el fichero completo\r\n\t- Exportar lista normalizada de actores: 78sec, 78051000ms\r\n\t- Exportar lista completa de actores: No es posible leer el fichero completo\r\n\r\n## 7. Conclusiones\r\n\r\nVolvemos a destacar, **la importancia de las búsquedas en el funcionamiento de nuestro programa.  **Al tener que trabajarlas tanto, es necesario optimizarlas al máximo para evitar tiempos de ejecución demasiado altos.\r\n\r\n**Destacar la dificultad añadida de trabajar con datos 'T' para hacer el metodo de adición de la lista OrderedCircularLinkedList**. Aunque finalmente entendimos como trabajar con la Interfaz Comparable<T> y nos sentimos mucho mas cómodos, pudiendo asi implementar dicha lista en FilmList.\r\n\r\n**Otro de los métodos con mucha importancia es cargarFichero()** dado que coge línea a línea el texto que hay en el fichero y lo trata. Es decir, elimina toda la información no relevante para el programa y añade la que si tiene importancia.\r\n\r\n**Tras analizar el fichero y destacar un patrón que pudiera servirnos** para, basandonos en el metodo split (de la clase String), separar las lineas del documento en información que nos fuera mas sencilla de manejar; **nos centramos en optimizar al máximo el funcionamiento de esta carga**.\r\nPara realizar la operacion de una forma mas transparente al usuario y sin saturar la ventana de la consola,** hemos desarrollado un metodo que calcula el procentaje actual del documento y la imprime por pantalla en bloques de 10% en 10%** y sin repetirse ninguna de las impresiones.\r\nAsí mismo, **hemos implementado programación basada en multiples procesos para aligerar la carga del fichero con la opción de normalización de nombres que hemos decidido aportar**. Las diferencias las detallaremos ahora con mas datos.\r\n\r\n\r\n#Practica. Actividad 1.\r\n\t\t\t\tUPV-EHU 2016/2017\r\n                            \r\n                            \r\n                            \r\n                Estructuras de Datos y Algoritmos\r\n                          \r\n\r\n              \r\n              \r\n                \r\n                \r\n                \t\t\t\t\t\t\t\t\t\t\tJosu Alvarez\r\n                                                            David Max\r\n\r\n* * * *\r\n##Indice\r\n\r\nMas informacion en la pagina web del proyecto: [GITHUB](http://txusyk.github.io/EDA16-17/): http://txusyk.github.io/EDA16-17/\r\n\r\n[TOC]\r\n\r\n* * *\r\n\r\n##1. Introducción\r\n\r\n**Dado un fichero de datos** que contiene actores y actrices de Internet Movie DataBase (IMDB), con una estructura efinida ('nombrePelicula' ---> 'nombreActor1' &&& 'nombreActor2'...) . **Se ha de implementar un programa que cargue el fichero de datos y extraiga del mismo los nombres de los actores y las peliculas que contiene**.\r\n\r\n**El pilar del funcionamiento de nuestro programa son las búsquedas**. Dado que tanto para añadir, eliminar como para gestionar alguno de los datos previamente se hará una búsqueda para comprobar si realmente existe.\r\n\r\nDado que disponiamos de tiempo y que el proyecto nos ha parecido interesante, **hemos decidido implementar ciertas mejoras sobre el trabajo inicial**, siendo estas:\r\n\r\n- ** El sistema dará la opción** al usuario para que decida como quiere ejecutar el programa, si por la **consola o bien mediante una GUI** que hemos construido con Swing.\r\n- **Hay dos formas de cargar el archivo**, una **con todos los datos y** otra **con los datos normalizados** (se explica mejor en las proximas lineas).\r\n- **Todo el proyecto** y todas sus versiones estan **siendo manejadas mediante GitHub**, se ha dispuesto una pagina web publica que contiene esta misma información y será actualizada con cada una de las proximas entregas.\r\n- **Uso exclusivo de lenguaje 'Markdown' para proceder a documentar el codigo**. En nuestro esfuerzo por usar tecnologías libres y ser eficientes, hemos encontrado este lenguaje ideal (dada su total compatibilidad con las wikis y las webs de GitHub).\r\n- **Uso del ingles** siempre que nos ha sido posible, para desarrollar el codigo de forma universal y que cualquier programador interesado lo pueda revisar, utilizar o mejorar desde el GitHub habilitado para ello.\r\n\r\n**Hemos definido que el programa cumpla** las siguientes funciones:\r\n\r\n1. ***Carga de datos desde fichero:* ** Se dará a elegir al usuario si quiere cargar la lista completa o solo querrá cargar los actores/peliculas que se encuentren bien escritos, es decir, que sean legibles tras haber sido tratados con un método que hemos establecido para normalizar nombres en base a caracteres desconocidos.\r\n1. ***Búsqueda de un actor/película:* ** Devolvera el actor en caso de existir, en caso contrario dará un aviso por terminal/pop-up.\r\n1. ***Inserción de un actor/película:* ** Indica si ha sido posible añadir el actor o si el mismo existía previamente.\r\n1. ***Eliminación de un actor/película:* ** Indica si el actor existe y en ese caso, que ha sido borrado. En caso contrario informará de que no existe.\r\n1. ***Obtener la lista de peliculas de un actor:* * ** Comprueba que el actor exista, y en caso positivo, muestra la lista de peliculas del mismo\r\n1. ***Obtener la lista de actores de una pelicula (reparto):* **  Comprobamos que la pelicula existe previamente y en caso positivo, imprimimos por pantalla los actores que la componen. En caso de no existir, se informará de dicha situación al usuario.\r\n1. ***Modificar el presupuesto de una pelicula:* ** Comprobamos que la pelicula introducida existe previamente y si es así, incrementamos el valor de recaudación en X (donde X es el valor introducido por el usuario). En caso de no existir la pelicula, se informará de dicha siatuación al usuario.\r\n1. ***Obtener una lista de actores ordenada (nombre, apellido):* ** Obtenemos una lista de actores ordenados bajo el criterio: Nombre Apellido (separados unicamente por un espacio)\r\n1. ***Exportar los datos a un fichero de texto:* ** Exportamos la lista ordenada de los actores, con sus respetivas peliculas a un fichero de texto `.txt`\r\n\r\n\r\n* * *\r\n\r\n## 2. Diagrama de clases\r\n\r\nEste es el diseño final del programa, los diseños iniciales y la evolución de los mismos hasta llegar a esta se encuentran en nuestro GitHub.\r\n\r\n![](/Users/Josu/IdeaProjects/EDA16-17/src/lab1/diagram.png)\r\n\r\n\r\n* * *\r\n\r\n\r\n## 3. Descripción de las estructuras de datos principales\r\n\r\nComo comentábamos en la introducción del documento, **la parte más importante** del documento recae en los métodos que realizan **las búsquedas**. Dado que **son necesarios para trabajar la información, añadir y eliminarla**.\r\n\r\nPara trabajar las búsquedas **inicialmente lo hacíamos mediante búsquedas lineales**, pero viendo que **el coste del mismo se disparaba al trabajar con grandes cantidades de datos**; **decidimos optar por usar el algoritmo de búsqueda binaria** (que solo funciona si la lista esta previamente ordenada). La **búsqueda lineal tenía un coste de *O(n)* mientras que la dicotómica/binaria *O(log n)* **.\r\n**Finalmente, vimos que podriamos tratar las búsquedas casi como un coste constante** si utilizabamos alguna estructura de datos de la familia **'Map'**. Por eso, replanteamos el diseño del programa e **hicimos que todas las estructuras de datos con las que trabajamos sean *HashMap < String, T >* ** donde 'T' es cualquier objeto que necesitemos almacenar (peliculas, actores...).\r\n\r\nTeniendo en cuenta que:\r\n- **n** es el numero de peliculas que hay en el fichero\r\n- **m** es el numero de actores que por pelicula del fichero (n)\r\n\r\n**Utilizando HashMap como estructura** de datos contenedora, el proceso de **cargar el fichero tiene un coste de *O(n*m)* **.Por un lado recorremos completamente el fichero de datos y por otro, tenemos que recorrer completamente la lista que estamos creando e inicializando con los datos del fichero. Al hacerlo mediante un hashmap, nos ahorramos la variable ‘p’ en el coste, dado que no tenemos que recorrer la listaAux (por que es un hashmap).\r\n\r\nComo **algoritmo de ordenación**, utilizábamos BubbleSort. Este, habia sido el algoritmo con el que mas habíamos trabajo y con el que mas cómodos nos sentiamos, pero al igual que en el anterior caso, decidimos hacer modificaciones debido a que su coste era demasiado alto para lo que buscábamos O(n2). Hicimos distintas pruebas con MergeSort, aunque **finalmente optamos como algoritmo por el QuickSort reduciendo así el coste hasta O(n* log n)**.\r\nPara realizar **la operación de ordenación**, previamente **volcamos las claves de nuestro HashMap** (que son los nombres de los actores) **en un Array[] de String y procedemos a ordenarlo**. **Tras esto, recibiremos una lista de claves ordenadas**, que en caso de querer mostrar unicamente los nombres de los actores cumple al 100% la función y en caso de querer mostrar mas información, lo recorreremos en orden y accederemos con cada clave a la información de nuestro catálogo (HashMap).\r\n\r\n## 4. Diseño e implementacion de los metodos principales\r\n\r\nEste apartado lo dedicaremos a explicar el funcionamiento de diferentes métodos principales, así como: readFile(), addActor(), removeActor(), searchActor() y quickSortList().\r\n\r\n###4.1. readFile():\r\n\r\n####4.1.1 Precondicion/Postcondicion\r\n++Precondicion:++ Tendremos un fichero\r\n++Postcondicion:++ El programa habra leido el fichero\r\n\r\n####4.1.2 Casos de prueba\r\n* Archivo null\r\n* Archivo correcto\r\n * Tras analizar el fichero, asumimos la posicion predefinida de los caracteres especiales.\r\n\r\n####4.1.3 Coste\r\n\r\nInicialmente deficimos hacer la lectura del fichero con un FileReader, pero acabamos viendo que no era eficiente (tiempos medios de 90s), también probamos con el metodo readAllLines() y volcarlo sobre una lista (34s aprox.), pero finalmente hemos optado por volcar en una lista (List< String >) el contenido de un BuffererReader e iterar sobre el con un *for* hasta llegar al final del documento a leer.\r\n\r\nEste algoritmo tratara de leer un fichero .txt en el que aparecen nombres de peliculas, y los actores que participan en ellas. Por ello, el programa estimamos que tendrá un coste de ***O(n x m)* **, donde n es la cantidad de actores, y m es la cantidad de peliculas.\r\n\r\n####4.1.4 Pseudo-algoritmo\r\n\r\n\t\tnew BufferedReader(FileReaderDelFicheroQueQueremosLeer)\r\n        contLineas = contadorLineas(nuevo File(\"Direccion\"))\r\n        auxCont = 0\r\n\r\n\t\tmientras siguienteLinea != null\r\n        \tguardamos en auxLinea1 = siguienteLinea.split (\" ---> \") la linea separadas \t\t  \ten: nombre de pelicula y actores\r\n        \tsi opcion == 1 entonces\r\n    \t   \tNormalizamos()\r\n\t\t\tfin si\r\n        \tnombrePelicula = auxLinea1[0]\r\n\t\t\tguardamos en auxLine2 = auxLinea1[1].split(\" &&& \") los nombres de los \t\t\t actores que participan en la pelicula en cuestión.\r\n        \tcreamos auxFilm = Film(nombrePelicula)\r\n       \t CatalogoPeliculas.getMiCatalogoPeliculas().añadirPelicula(auxFilm)\r\n    \t    creamos varable temporal i = 0 como contador\r\n     \t   mientras(auxLine2.lenght > i)\r\n      \t  \tnombreActor = auxLine2[i]\r\n        \t    apellidoActor = \"\"\r\n            \tsi (nombreActor.contiene(\"(\")) entonces\r\n            \t\tauxLinea1 = nombreActor.split(\" (\")\r\n                \tnombreActor = auxLinea1[0]\r\n           \t fin si\r\n            \tsi (nombreActor.contiene(\",\")) entonces\r\n            \t\tauxLinea1 = nombreActor.split(\", \")\r\n                \tsi(auxLinea1.length > 1) entonces\r\n                    \tsi(auxLinea1[1].comparar(\"null\") != 0) entonces\r\n                        \tapellidoActor = auxLinea1[0]\r\n                            nombreActor = auxLinea1[1]\r\n                        si no\r\n                        \tnombreActor = auxLinea[0]\r\n                        fin si\r\n                   fin si\r\n\t\t\t\tfin si\r\n            \tauxActor = nuevo Actor(nombreActor, apellidoActor)\r\n                si (opcion = 1) entonces\r\n                \tsi (!auxActor.getNombre().contiene(\"�\")) entonces\r\n                    \tsi(auxActor.getName().charEn(0) > 'A' && \t\t\t\t\t\t\t\t\t\t\t\tauxActor.getName().charEn(0) < 'Z') entonces\r\n                        \tauxActor.obtenerListaPeliculas().añadirPelicula(auxFilm)\r\n                            CatalogoActores.getMiCatalogoActores().añadirActor(auxActor)\r\n                            si (!auxFilm.getName().contiene(\"�\")) entonces\r\n                            \tCatalogoPelis.getMiCatalogoPelis().getPelicula(auxFilm.g\t\t\t\t\t\t\tetName()).getListaActores().añadirActor(auxActor)\r\n                            fin si\r\n                       fin si\r\n                   fin si\r\n\t\t\t\tsi no\r\n\t\t\t\t\tauxActor.getListaPeliculas().añadirPelicula(auxFilm)\r\n                \tCatalogoActores.getMiCatalogoActores().addActor(auxActor)\r\n                \tCatalogoPelis.getMiCatalogoPelis().getPelicula(auxFilm.getNombre()).\t\t\t\tgetListaActores().addActor(auxActor)\r\n               fin si\r\n               i++\r\n        \tfin mientras\r\n        \tsi (j==0) entonces\r\n        \t\tSystem.out.println(\"\\t[*] 0% file readed\")\r\n\t\t\tfin si\r\n        \tsi (((j*100)/contLineas) % 5 == 0) entonces\r\n        \t\tsi(((j*100)/contLineas) != auxCont) entonces\r\n            \t\tauxCont = ((j*100)(contLineas))\r\n                \tLong stopTime = System.currentTimeMilis()\r\n                \ttotal = (int) (stopTime - startTime) / 1000\r\n                \tSystem.out.println(\"\\t[*] \" + auxCont + \"% file readed. Time elapsed\t\t\t\t: \" + total + \"s\")\r\n            \tfin si\r\n        \tsi no, si (((j*100)/contLineas) % 5 == 0) entonces\r\n       \t \tJMenu.getMiJMenu().actualizarBarra((j * 100) / contLineas)\r\n\t\t\tfin si\r\n\t\tfin mientras\r\n\r\n####4.1.5 Método final\r\n\r\n```java\r\npublic void readFile(int pOption) throws IOException {\r\n\r\n        String[] auxLine1;\r\n\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        int j = 0; //j= counts the actual line of file\r\n        int total = 0; //total = saves total running time of reading\r\n        int auxCont = 0;  //auxCount = saves the percentage of reading of file\r\n\r\n        try (InputStream resource = FileManager.class.getResourceAsStream(\"testAllActors.txt\")) {\r\n\r\n            int contLines = countLines(new File(\"/Users/Josu/IdeaProjects/EDA16-17/src/lab1/testAllActors.txt\"));\r\n\r\n            String filmName, actorName, actorSurname;\r\n\r\n            String[] auxLine2;\r\n\r\n            Film auxFilm;\r\n\r\n            List<String> lines = new BufferedReader(new InputStreamReader(resource, StandardCharsets.UTF_8)).lines().collect(Collectors.toList());\r\n\r\n            for (String line : lines) {\r\n\r\n                auxLine1 = line.split(\"\\\\s+\\\\--->+\\\\s\"); //we split to get the name of the movie\r\n\r\n                if (pOption == 1) {\r\n                    NormalizeStrings.getMyNormalizeString().run(auxLine1);\r\n                }\r\n\r\n                filmName = auxLine1[0]; //here we save the name of the film\r\n\r\n                auxLine2 = auxLine1[1].split(\"\\\\s+\\\\&&&+\\\\s\"); //we split the array of actors in\r\n\r\n                auxFilm = new Film(filmName); //create a new film\r\n\r\n                if (pOption == 1) {\r\n                    if (!auxFilm.getName().contains(\"�\")) {\r\n                        FilmCatalog.getMyFilmCatalog().addFilm(auxFilm); //we add the film if its not been added before\r\n                    }\r\n                } else {\r\n                    FilmCatalog.getMyFilmCatalog().addFilm(auxFilm); //we add the film if its not been added before\r\n                }\r\n\r\n                int i = 0;\r\n\r\n                while (auxLine2.length > i) { // mientras el indice no sea mayor que el tamaño de la lista(indexOutOfBoundException)\r\n\r\n                    actorSurname = \"\";\r\n                    actorName = auxLine2[i];\r\n\r\n                    if (actorName.contains(\"(\")) {\r\n                        auxLine1 = actorName.split(\"\\\\s\\\\(\");\r\n                        actorName = auxLine1[0];\r\n                    }\r\n                    if (actorName.contains(\",\")) {//convertimos -> Apellido, Nombre --> Nombre, Apellido (como es habitual)\r\n                        auxLine1 = actorName.split(\",\\\\s*\");\r\n                        if (auxLine1.length > 1) {\r\n                            if (auxLine1[1].compareToIgnoreCase(\"null\") != 0) {\r\n                                actorSurname = auxLine1[0];\r\n                                actorName = auxLine1[1];\r\n                            } else {\r\n                                actorName = auxLine1[0];\r\n                            }\r\n                        }\r\n                    }\r\n                    Actor auxActor = new Actor(actorName, actorSurname);//Creamos la pelicula enviandole el nombre una vez normalizado\r\n\r\n                    if (pOption == 1) {\r\n                        if (!auxActor.getName().contains(\"�\")) {\r\n                            if (auxActor.getName().charAt(0) > 'A' && auxActor.getName().charAt(0) < 'Z') {\r\n                                auxActor.getFilmList().addFilm(auxFilm);\r\n                                ActorCatalog.getmyActorCatalog().addActor(auxActor);\r\n                                if (!auxFilm.getName().contains(\"�\")) {\r\n                                    FilmCatalog.getMyFilmCatalog().getFilm(auxFilm.getName()).getActorList().addActor(auxActor);\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        auxActor.getFilmList().addFilm(auxFilm);\r\n                        ActorCatalog.getmyActorCatalog().addActor(auxActor);\r\n                        FilmCatalog.getMyFilmCatalog().getFilm(auxFilm.getName()).getActorList().addActor(auxActor);\r\n                    }\r\n\r\n                    i++;\r\n\r\n                }\r\n                if (j == 0) {\r\n                    System.out.println(\"\\t[*] 0% file readed\");\r\n                }\r\n                j++;\r\n\r\n                if (((j * 100) / contLines) % 5 == 0) {\r\n                    if (((j * 100) / contLines) != auxCont) {\r\n                        auxCont = ((j * 100) / contLines);\r\n                        long stopTime = System.currentTimeMillis();\r\n                        total = (int) (stopTime - startTime) / 1000;\r\n\r\n                        System.out.println(\"\\t[*] \" + auxCont + \"% file readed. Time elapsed: \" + total + \"s\");\r\n                    }\r\n                } else if (((j * 100) / contLines) % 5 == 0) {\r\n                    SwingGUI.getMyJMenu().updateBar((j * 100) / contLines);\r\n                }\r\n            }\r\n        }\r\n        System.out.println(\"\\t-------- File read finished --------\\n\");\r\n        System.out.println(\"\\t--- Elapsed time to read the file ---> \" + total + \"s---\");\r\n        System.out.println(\"\\t--- Total actor/actresses found :\" + ActorCatalog.getmyActorCatalog().getActorL().size());\r\n        System.out.println(\"\\t--- Total films found : \" + FilmCatalog.getMyFilmCatalog().getSize());\r\n    }\r\n\r\n```\r\n### 4.2 buscarActor(String nombreActor)\r\n#### 4.2.1 Precondición/Postcondición\r\n- ++Pre:++ La lista no esta ordenada. No se repiten elementos.\r\n- ++Post:++ Obtenemos un actor de la lista en caso de existir, en caso contario obtendremos null.\r\n\r\n#### 4.2.2 Casos de prueba\r\n- El elemento no está en la lista\r\n- El elemento está en la lista\r\n\t- Es el primero de la lista\r\n\t- Está en una posición aleatoria (middle) o Es el último de la lista\r\n\r\n#### 4.2.3 Coste\r\n\r\nTenemos los actores guardados en una estructura de datos de tipo ***HashMap < String, Actor >* **, no es necesario hacer una 'busqueda' en si misma. Se reduce a acceder a un dato desde una clave.\r\nEl coste del algoritmo por lo tanto, es ***O(1)* **.\r\n\r\n#### 4.2.4 Pseudo-algoritmo\r\n\r\n```\r\nclase publica buscarActor (String nombreActor)\r\n\tsi (listaActores.obtener(nombreActor) es distinto de null entonces\r\n    \tdevuelve listaActores.obtener(nombreActor)\r\n    si no\r\n    \tdevuelve null\r\n\r\n```\r\n\r\n#### 4.2.5 Metodo final (código)\r\n\r\n```java\r\npublic Actor searchActor(Actor pActor) {\r\n        if (this.exist(pActor.getName(), pActor.getSurname())) {\r\n            return this.actorL.get(pActor.getName() + \" \" + pActor.getSurname());\r\n        }\r\n        return null;\r\n}\r\n\r\n```\r\n\r\nEste método, utiliza otro método definido previamente:\r\n\r\n```java\r\nprivate boolean exist(String pActorName, String pActorSurname) {\r\n\treturn actorL.get(pActorName + \" \" + pActorSurname) != null;\r\n}\r\n\r\n```\r\n\r\n* * *\r\n###4.3 addActor()\r\n\r\n\r\n####4.3.1 Precondicion/Postcondicion\r\n- ++Precondicion:++ Tendremos un actor.\r\n- ++Postcondicion:++ El programa habra añadido el actor a la lista.\r\n\r\n####4.3.2 Casos de prueba\r\n* Actor null\r\n* Actor existente ya en la lista\r\n* Nombre vacio\r\n\r\n####4.3.3 Coste\r\nEste método recibirá un objeto pActor, y lo que tendrá que hacer es comprobar si ese actor ya existe en el catálogo, y para ello, al estar usando estructuras HashMap, el coste que tendrá será constante; por consiguiente el coste del método completo de añadirActor() será lineal ya que la otra llamada de la que hacemos uso es put() que no aumentara apenas el coste.\r\n\r\n####4.3.4 Pseudo-algoritmo\r\n\r\n\tsi (!this.existe(pActor.getNombre(), pActor.getApellido)) entonces\r\n    \tthis.listaActores.poner(pActor.getNombre() + \" \"+pActor.getApellido(), pActor)\r\n    fin si\r\n\r\n\r\n####4.3.5 Método final\r\n\r\n```java\r\n public void addActor(Actor pActor) {\r\n        if (!this.exist(pActor.getName(), pActor.getSurname())) {\r\n            this.actorL.put(pActor.getName() + \" \" + pActor.getSurname(), pActor);\r\n        }\r\n }\r\n\r\n```\r\n\r\n##4.5 sortImpl()\r\n\r\n###4.5.1 Precondicion/PostCondicion\r\n- ++Precondición++: El programa recibe un array de Strings que tendrá los nombres de los actores, y dos números que nos servirán de índices.\r\n- ++Postcondición++: Tras ejecutar el programa nuestro cátalogo de actores estará ordenado alfabeticamente.\r\n\r\n###4.5.2 Casos de prueba\r\n* Lista vacía\r\n* Lista no vacía.\r\n\r\n###4.5.3 Coste\r\n\r\nEn el mejor caso, el pivote termina en el centro de la lista, dividiéndola en dos sublistas de igual tamaño. En este caso, el orden de complejidad del algoritmo es ***O(n·log n)* **.\r\nEn el peor caso, el pivote termina en un extremo de la lista. El orden de complejidad del algoritmo es entonces de ***O(n²)* **. El peor caso dependerá de la implementación del algoritmo, aunque habitualmente ocurre en listas que se encuentran ordenadas, o casi ordenadas.\r\nEn el caso promedio, el orden es ***O(n·log n)* **.\r\n\r\n###4.5.4 Pseudo-algoritmo\r\n\r\n\t private static void sortImpl(String[] array, int pivoteInicio, int pivoteFinal, int tamañoString) throws NullPointerException {\r\n\r\n\r\n\t\tint rango = pivoteFinal - pivoteInicio\r\n        \r\n\t\tsi (rango < 2) entonces\r\n        \treturn;\r\n        fin si\r\n\r\n\t\tint selec = pivoteInicio\r\n\r\n        mientras(int index = pivoteInicio; index < pivoteFinal; ++index)\r\n        \tString actual = array(index)\r\n            si(actual.length() == stringLength) entonces\r\n            \tString temp = array[selec]\r\n                array[selec] = actual\r\n                array[index] = tmp\r\n                ++finger\r\n            fin si\r\n       fin mientras\r\n       \r\n\t\tpivoteInicio = selec\r\n       \r\n        String izq = array[pivoteInicio];\r\n        String dcha = array[pivoteFinal - 1];\r\n        String medio = array[pivoteInicio + rango >> 1];\r\n\r\n        String pivote = medio(izq, medio, dhca);\r\n        \r\n\t\tmientras (int index = pivoteInicio; index < pivoteFinal; ++index)\r\n        \tString actual = array[index]\r\n            \r\n            si(actual.charEn(tamañoString) < pivote.charEn(tamañoString)) entonces\r\n            \tString tmp=array[selec]\r\n                array[selec] = actual\r\n                array[index] = tmp\r\n\t\t\t\t++finger\r\n            fin si\r\n        fin mientras\r\n        \r\n        sortImpl(array, pivoteInicio, selec, tamañoString)\r\n\r\n        pivoteInicio = selec\r\n\r\n        mientras (int index = pivoteInicio; index < pivoteFinal; ++index)\r\n        \tString actual = array[index]\r\n\t\t\t\r\n            si (actual.charEn(tamañoString) == pivote.charEn(tamañoString)) entonces\r\n            \tString tmp = array[selec]\r\n                array[selec] = actual\r\n                array[index] = tmp\r\n                ++finger\r\n            fin si\r\n        fin mientras    \r\n          \r\n\t\tsortImp(array, pivoteInicio, selec, tamañoString + 1)\r\n        sortImpl(array, selec, pivoteFinal, tamañoString)\r\n   \t}\r\n    \r\n    \r\n###4.5.5 Método final\r\n\r\n```java\r\nprivate static void sortImpl(String[] array, int fromIndex, int toIndex, int stringLength) throws NullPointerException {\r\n\r\n\r\n\r\n        int rangeLength = toIndex - fromIndex;\r\n\r\n        if (rangeLength < 2) {\r\n            return;\r\n        }\r\n\r\n        int finger = fromIndex;\r\n\r\n        // Put all strings of length 'stringLength' to the beginning of the\r\n        // requested sort range.\r\n        for (int index = fromIndex; index < toIndex; ++index) {\r\n            String current = array[index];\r\n            if (current.length() == stringLength) {\r\n                String tmp = array[finger];\r\n                array[finger] = current;\r\n                array[index] = tmp;\r\n                ++finger;\r\n            }\r\n        }\r\n\r\n        fromIndex = finger;\r\n\r\n        // Choose a pivot string by median.\r\n        String probeLeft = array[fromIndex];\r\n        String probeRight = array[toIndex - 1];\r\n        String probeMiddle = array[fromIndex + rangeLength >> 1];\r\n\r\n        String pivot = median(probeLeft, probeMiddle, probeRight);\r\n\r\n        // Process strings S for which S[stringLength] < X[stringLength].\r\n        for (int index = fromIndex; index < toIndex; ++index) {\r\n            String current = array[index];\r\n\r\n            if (current.charAt(stringLength) < pivot.charAt(stringLength)) {\r\n                String tmp = array[finger];\r\n                array[finger] = current;\r\n                array[index] = tmp;\r\n                ++finger;\r\n            }\r\n        }\r\n\r\n        sortImpl(array, fromIndex, finger, stringLength);\r\n\r\n        fromIndex = finger;\r\n\r\n        for (int index = fromIndex; index < toIndex; ++index) {\r\n            String current = array[index];\r\n\r\n            if (current.charAt(stringLength) == pivot.charAt(stringLength)) {\r\n                String tmp = array[finger];\r\n                array[finger] = current;\r\n                array[index] = tmp;\r\n                ++finger;\r\n            }\r\n        }\r\n\r\n        sortImpl(array, fromIndex, finger, stringLength + 1);\r\n        sortImpl(array, finger, toIndex, stringLength);\r\n    }\r\n\r\n```\r\n\r\n###4.6 contLines()\r\n\r\n###4.6.1 Precondición/Postcondición\r\n* ++Precondición++: Tenemos un fichero.\r\n* ++Postcondición++: Nos devolverá la cantidad de lineas que tiene.\r\n\r\n###4.6.2 Explicacion del algoritmo\r\n\r\nPara evitar sobrecargar la pantalla de la consola, ralentizar la carga de datos y asi mismo hacerla mas trasparente para el usuario, hemos decidido implementar un contador de lineas que combinado con la linea actual y un submetodo que acompaña, imprime por pantalla la información relativa a la carga del fichero en bloques de `%5`.\r\n\r\n###4.6.4 Código\r\n\r\nMetodo que lee todas las lineas y nos devuelve un *int*, siendo este el numero de lineas totales del fichero a cargar.\r\n\r\n```java\r\n public static int countLines(File pFile) throws IOException {\r\n        LineNumberReader lnr = new LineNumberReader(new FileReader(pFile));\r\n        lnr.skip(Long.MAX_VALUE);\r\n        lnr.close();\r\n        return lnr.getLineNumber() + 1;//Add 1 because line index starts at 0\r\n    }\r\n```\r\nEste es el submetodo que es llamado en las iteraciones de la carga para mostrar la información por pantalla al usuario (en bloques de `5%`)\r\n\r\n```java\r\n    if (((i * 100) / ActorCatalog.getmyActorCatalog().getActorL().size()) % 5 == 0) {\r\n    \tif (((i * 100) / ActorCatalog.getmyActorCatalog().getActorL().size()) != percentage) {\r\n    \t\tSystem.out.println(\"\\t\\t[*] \" + percentage + \"%\");\r\n          }\r\n    }    \r\n\r\n```\r\n\r\n## 5. Código completo\r\n\r\n- Se incluye el **diagrama de clases** completo en formato `.png`\r\n- **Los ficheros `.java`** que contienen todos los métodos\r\n- **Los ficheros resultado** de la carga del fichero original\r\n\t- Fichero resultado con los actores y peliculas con nombres normalizados (y descartando aquellos que tras el proceso seguian estando mal escritos)\r\n\t- Fichero resultado con todos los actores y peliculas que nuestro programa trata en la carga\r\n\r\n### 5.1 Actor\r\n```java\r\npublic class Actor {\r\n\r\n    private String name;\r\n    private String surname;\r\n    private FilmList filmL;\r\n\r\n    public Actor(String pName, String pSurname) {\r\n        this.name = pName;\r\n        this.surname = pSurname;\r\n        this.filmL = new FilmList();\r\n    }\r\n\r\n    public FilmList getFilmList() {\r\n        return this.filmL;\r\n    }\r\n\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    public String getSurname() {\r\n        return this.surname;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 5.2 ActorCatalog\r\n```java\r\npublic class ActorCatalog {\r\n\r\n    private static ActorCatalog myActorCatalog;\r\n    private HashMap<String, Actor> actorL;\r\n\r\n    private ActorCatalog() {\r\n        this.actorL = new HashMap<>();\r\n    }\r\n\r\n    public static ActorCatalog getmyActorCatalog() {\r\n        if (myActorCatalog == null) {\r\n            myActorCatalog = new ActorCatalog();\r\n        }\r\n        return myActorCatalog;\r\n    }\r\n\r\n    public HashMap<String, Actor> getActorL() {\r\n        return this.actorL;\r\n    }\r\n\r\n    private boolean exist(String pActorName, String pActorSurname) {\r\n        return actorL.get(pActorName + \" \" + pActorSurname) != null;\r\n    }\r\n\r\n    public void addActor(Actor pActor) {\r\n        if (!this.exist(pActor.getName(), pActor.getSurname())) {\r\n            this.actorL.put(pActor.getName() + \" \" + pActor.getSurname(), pActor);\r\n        }\r\n    }\r\n\r\n    public Actor searchActor(Actor pActor) {\r\n        if (this.exist(pActor.getName(), pActor.getSurname())) {\r\n            return this.actorL.get(pActor.getName() + \" \" + pActor.getSurname());\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public void removeActor(Actor pActor) {\r\n        if (this.exist(pActor.getName(), pActor.getSurname())) {\r\n            this.actorL.remove(pActor.getName() + \" \" + pActor.getSurname());\r\n            System.out.println(\"Actor erased\");\r\n        } else {\r\n            System.out.println(\"Actor not found\");\r\n        }\r\n    }\r\n\r\n    public String[] quickSortList() {\r\n        String[] auxS = new String[actorL.size()];\r\n        int i = 0;\r\n        for (String key : actorL.keySet()) {\r\n            auxS[i] = key;\r\n            i++;\r\n        }\r\n        StringQuickSort.sort(auxS);\r\n        return auxS;\r\n    }\r\n\r\n    public void printList(String[] auxS) {\r\n        for (String key : auxS) {\r\n            System.out.println(key);\r\n        }\r\n    }\r\n}\r\n```\r\n### 5.3 ActorList\r\n```java\r\npublic class ActorList {\r\n\r\n    private HashMap<String, Actor> actorList;\r\n\r\n\r\n    public ActorList() {\r\n        this.actorList = new HashMap<>();\r\n    }\r\n\r\n\r\n    public boolean exist(String pActorName, String pActorSurname) {\r\n        return this.actorList.get(pActorName + \" \" + pActorSurname) != null;\r\n    }\r\n\r\n    public void addActor(Actor auxActor) {\r\n        if (!this.exist(auxActor.getName(), auxActor.getSurname())) {\r\n            this.actorList.put(auxActor.getName() + \" \" + auxActor.getSurname(), auxActor);\r\n        }\r\n    }\r\n\r\n    public Actor getActor(String pActorName, String pActorSurname) {\r\n        if (this.actorList.get(pActorName + \" \" + pActorSurname) != null) {\r\n            return actorList.get(pActorName);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public void removeActor(Actor pActor) {\r\n        if (this.actorList.get(pActor.getName() + \" \" + pActor.getSurname()) != null) {\r\n            this.actorList.remove(pActor.getName() + \" \" + pActor.getSurname());\r\n        }\r\n    }\r\n\r\n    public void printActors() {\r\n        System.out.println(\"These are all the actors: \");\r\n        for (HashMap.Entry<String, Actor> entry : actorList.entrySet()) {\r\n            String key = entry.getKey();\r\n            System.out.println(key.toString());\r\n        }\r\n    }\r\n}\r\n```\r\n### 5.4 EDA1617\r\n```java\r\npublic class EDA1516 {\r\n\r\n    /**\r\n     * @param args the command line arguments\r\n     */\r\n    public static void main(String[] args) throws FileNotFoundException {\r\n\r\n        Object[] options = {\"GUI based\", \"Console based\"};\r\n\r\n        //int n = JOptionPane.showOptionDialog(null,\"Choose what launcher do you want to use\", \"EDA16-17 Selection Menu\",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[1])\r\n\r\n        System.out.println(\"\\t\\t***** Welcome to EDA16/17 project *****\\n\");\r\n\r\n        System.out.println(\"\\tSelect (1) for gui based program launch (still in development, less customizable)\");\r\n        System.out.println(\"\\tSelect (2) for terminal based program launch (finished and more customizable experience\");\r\n\r\n        int n = Keyboard.getMyKeyboard().getInt();\r\n\r\n        if (n == 1) {\r\n\r\n            JFrame frame = SwingGUI.getMyJMenu();\r\n\r\n            Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();         //En dim guardamos el tamaño de la pantalla donde se esta ejecutando el programa\r\n\r\n            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //fijamos que la operacion por defecto al cerrar es salir\r\n            frame.pack();\r\n            frame.isAlwaysOnTop();\r\n            frame.setLocation(dim.width / 2 - frame.getSize().width / 2, dim.height / 2 - frame.getSize().height / 2);         //Fijamos por defecto que la ventana siempre aparezca en el centro\r\n            frame.setVisible(true); //hacemos el frame visible\r\n            frame.setResizable(false);\r\n        } else {\r\n            TerminalUI.main();\r\n        }\r\n    }\r\n}\r\n```\r\n### 5.5 FileManager\r\n```java\r\npublic class FileManager {\r\n\r\n    private static FileManager myFileManager;\r\n\r\n    private FileManager() {\r\n\r\n    }\r\n\r\n    public static FileManager getMyFileManager() {\r\n        if (myFileManager == null) {\r\n            myFileManager = new FileManager();\r\n        }\r\n        return myFileManager;\r\n    }\r\n\r\n    public static int countLines(File pFile) throws IOException {\r\n        LineNumberReader lnr = new LineNumberReader(new FileReader(pFile));\r\n        lnr.skip(Long.MAX_VALUE);\r\n        lnr.close();\r\n        return lnr.getLineNumber() + 1;//Add 1 because line index starts at 0\r\n    }\r\n\r\n    public void readFile(int pOption) throws IOException {\r\n\r\n        String[] auxLine1;\r\n\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        int j = 0; //j= counts the actual line of file\r\n        int total = 0; //total = saves total running time of reading\r\n        int auxCont = 0;  //auxCount = saves the percentage of reading of file\r\n\r\n        try (InputStream resource = FileManager.class.getResourceAsStream(\"testAllActors.txt\")) {\r\n\r\n            int contLines = countLines(new File(\"/Users/Josu/IdeaProjects/EDA16-17/src/lab1/testAllActors.txt\"));\r\n\r\n            String filmName, actorName, actorSurname;\r\n\r\n            String[] auxLine2;\r\n\r\n            Film auxFilm;\r\n\r\n            List<String> lines = new BufferedReader(new InputStreamReader(resource, StandardCharsets.UTF_8)).lines().collect(Collectors.toList());\r\n\r\n            for (String line : lines) {\r\n\r\n                auxLine1 = line.split(\"\\\\s+\\\\--->+\\\\s\"); //we split to get the name of the movie\r\n\r\n                if (pOption == 1) {\r\n                    NormalizeStrings.getMyNormalizeString().run(auxLine1);\r\n                }\r\n\r\n                filmName = auxLine1[0]; //here we save the name of the film\r\n\r\n                auxLine2 = auxLine1[1].split(\"\\\\s+\\\\&&&+\\\\s\"); //we split the array of actors in\r\n\r\n                auxFilm = new Film(filmName); //create a new film\r\n\r\n                if (pOption == 1) {\r\n                    if (!auxFilm.getName().contains(\"�\")) {\r\n                        FilmCatalog.getMyFilmCatalog().addFilm(auxFilm); //we add the film if its not been added before\r\n                    }\r\n                } else {\r\n                    FilmCatalog.getMyFilmCatalog().addFilm(auxFilm); //we add the film if its not been added before\r\n                }\r\n\r\n                int i = 0;\r\n\r\n                while (auxLine2.length > i) { // mientras el indice no sea mayor que el tamaño de la lista(indexOutOfBoundException)\r\n\r\n                    actorSurname = \"\";\r\n                    actorName = auxLine2[i];\r\n\r\n                    if (actorName.contains(\"(\")) {\r\n                        auxLine1 = actorName.split(\"\\\\s\\\\(\");\r\n                        actorName = auxLine1[0];\r\n                    }\r\n                    if (actorName.contains(\",\")) {//convertimos -> Apellido, Nombre --> Nombre, Apellido (como es habitual)\r\n                        auxLine1 = actorName.split(\",\\\\s*\");\r\n                        if (auxLine1.length > 1) {\r\n                            if (auxLine1[1].compareToIgnoreCase(\"null\") != 0) {\r\n                                actorSurname = auxLine1[0];\r\n                                actorName = auxLine1[1];\r\n                            } else {\r\n                                actorName = auxLine1[0];\r\n                            }\r\n                        }\r\n                    }\r\n                    Actor auxActor = new Actor(actorName, actorSurname);//Creamos la pelicula enviandole el nombre una vez normalizado\r\n\r\n                    if (pOption == 1) {\r\n                        if (!auxActor.getName().contains(\"�\")) {\r\n                            if (auxActor.getName().charAt(0) > 'A' && auxActor.getName().charAt(0) < 'Z') {\r\n                                auxActor.getFilmList().addFilm(auxFilm);\r\n                                ActorCatalog.getmyActorCatalog().addActor(auxActor);\r\n                                if (!auxFilm.getName().contains(\"�\")) {\r\n                                    FilmCatalog.getMyFilmCatalog().getFilm(auxFilm.getName()).getActorList().addActor(auxActor);\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        auxActor.getFilmList().addFilm(auxFilm);\r\n                        ActorCatalog.getmyActorCatalog().addActor(auxActor);\r\n                        FilmCatalog.getMyFilmCatalog().getFilm(auxFilm.getName()).getActorList().addActor(auxActor);\r\n                    }\r\n\r\n                    i++;\r\n\r\n                }\r\n                if (j == 0) {\r\n                    System.out.println(\"\\t[*] 0% file readed\");\r\n                }\r\n                j++;\r\n\r\n                if (((j * 100) / contLines) % 5 == 0) {\r\n                    if (((j * 100) / contLines) != auxCont) {\r\n                        auxCont = ((j * 100) / contLines);\r\n                        long stopTime = System.currentTimeMillis();\r\n                        total = (int) (stopTime - startTime) / 1000;\r\n\r\n                        System.out.println(\"\\t[*] \" + auxCont + \"% file readed. Time elapsed: \" + total + \"s\");\r\n                    }\r\n                } else if (((j * 100) / contLines) % 5 == 0) {\r\n                    SwingGUI.getMyJMenu().updateBar((j * 100) / contLines);\r\n                }\r\n            }\r\n        }\r\n        System.out.println(\"\\t-------- File read finished --------\\n\");\r\n        System.out.println(\"\\t--- Elapsed time to read the file ---> \" + total + \"s---\");\r\n        System.out.println(\"\\t--- Total actor/actresses found :\" + ActorCatalog.getmyActorCatalog().getActorL().size());\r\n        System.out.println(\"\\t--- Total films found : \" + FilmCatalog.getMyFilmCatalog().getSize());\r\n    }\r\n\r\n    @SuppressWarnings(\"rawtypes\")\r\n    public void exportToFile() {\r\n\r\n        String[] keys = ActorCatalog.getmyActorCatalog().quickSortList();\r\n\r\n        FileWriter fichero = null;\r\n        PrintWriter pw;\r\n\r\n        long timeStart = System.currentTimeMillis();\r\n\r\n        try {\r\n            String directorio = System.getProperty(\"user.dir\");//cogemos variable entorno\r\n            fichero = new FileWriter(directorio + \"/ActorList_ordered.txt\");\r\n            pw = new PrintWriter(fichero);\r\n\r\n            int i = 1;\r\n            for (int i1 = 0, keysLength = keys.length; i1 < keysLength; i1++) {\r\n                Object key = keys[i1];\r\n                pw.print(\"Actor \" + i + \" -> \");\r\n                pw.println(ActorCatalog.getmyActorCatalog().getActorL().get(key).getName() + \" \" + ActorCatalog.getmyActorCatalog().getActorL().get(key).getSurname());\r\n                Object[] keys2;\r\n                keys2 = ActorCatalog.getmyActorCatalog().getActorL().get(key).getFilmList().getFilmL().keySet().toArray();\r\n                for (Object auxKey : keys2) {\r\n                    pw.println(\"\\t\" + ActorCatalog.getmyActorCatalog().getActorL().get(key).getFilmList().getFilmL().get(auxKey).getName());\r\n                }\r\n                i++;\r\n                int percentage = (i * 100) / ActorCatalog.getmyActorCatalog().getActorL().size();\r\n                if (((i * 100) / ActorCatalog.getmyActorCatalog().getActorL().size()) % 5 == 0) {\r\n                    if (((i * 100) / ActorCatalog.getmyActorCatalog().getActorL().size()) != percentage) {\r\n                        System.out.println(\"\\t\\t[*] \" + percentage + \"%\");\r\n                    }\r\n                }\r\n\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                if (null != fichero) {\r\n                    fichero.close();\r\n                }\r\n                long timeTotal = (System.currentTimeMillis() - timeStart);\r\n                System.out.println(\"\\t\\t --- Elapsed time to export the file --- : \" + (int) timeTotal / 1000 + \"sec, \" + timeTotal * 1000 + \"ms\\n\");\r\n                System.out.println(\"\\n\\tFile exported to: \" + System.getProperty(\"user.dir\"));\r\n            } catch (Exception e2) {\r\n                e2.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n### 5.6 Film\r\n```java\r\npublic class Film {\r\n    private String name;\r\n    private int earned = 0;\r\n    private ActorList actorList;\r\n\r\n    public Film(String pName) {\r\n        this.name = pName;\r\n        this.actorList = new ActorList();\r\n    }\r\n\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    public int getEarned() {\r\n        return this.earned;\r\n    }\r\n\r\n    public void incrementEarned(int auxEarned) {\r\n        this.earned += auxEarned;\r\n    }\r\n\r\n    public ActorList getActorList() {\r\n        return this.actorList;\r\n    }\r\n}\r\n```\r\n### 5.7 FilmCatalog\r\n```java\r\npublic class FilmCatalog {\r\n\r\n    private static FilmCatalog myFilmCatalog;\r\n    private HashMap<String, Film> filmL;\r\n\r\n    private FilmCatalog() {\r\n        this.filmL = new HashMap<>();\r\n    }\r\n\r\n    public static FilmCatalog getMyFilmCatalog() {\r\n        if (myFilmCatalog == null) {\r\n            myFilmCatalog = new FilmCatalog();\r\n        }\r\n        return myFilmCatalog;\r\n    }\r\n\r\n    public boolean exist(String pFilmName) {\r\n        return filmL.get(pFilmName) != null;\r\n    }\r\n\r\n    public void addFilm(Film pFilm) {\r\n        if (!this.exist(pFilm.getName())) {\r\n            this.filmL.put(pFilm.getName(), pFilm);\r\n        }\r\n    }\r\n\r\n    public Film getFilm(String pFilmName) {\r\n        if (this.exist(pFilmName)) {\r\n            return this.filmL.get(pFilmName);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public int getSize(){\r\n        return this.filmL.size();\r\n    }\r\n}\r\n```\r\n### 5.8 FilmList\r\n```java\r\npublic class FilmList {\r\n\r\n    private HashMap<String, Film> filmL;\r\n\r\n    public FilmList() {\r\n        this.filmL = new HashMap<>();\r\n    }\r\n\r\n\r\n    private boolean exist(String pFilmName) {\r\n        return this.filmL.get(pFilmName) != null;\r\n    }\r\n\r\n    public void addFilm(Film pFilm) {\r\n        if (!this.exist(pFilm.getName())) {\r\n            this.filmL.put(pFilm.getName(), pFilm);\r\n        }\r\n    }\r\n\r\n    public Film getFilm(String pFilmName) {\r\n        if (this.filmL.get(pFilmName) != null) {\r\n            return this.filmL.get(pFilmName);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public HashMap<String, Film> getFilmL() {\r\n        return this.filmL;\r\n    }\r\n\r\n    public void printFilms() {\r\n        System.out.println(\"These are all the films: \");\r\n        for (HashMap.Entry<String, Film> entry : filmL.entrySet()) {\r\n            String key = entry.getKey();\r\n            System.out.println(key.toString());\r\n        }\r\n    }\r\n}\r\n```\r\n### 5.9 Keyboard\r\n```java\r\npublic class Keyboard {\r\n\r\n\tprivate static Keyboard miKeyboard;\r\n\tprivate Scanner scan;\r\n\t\r\n\tpublic Keyboard(){\r\n\t\tscan = new Scanner(System.in);\r\n\t}\r\n\t\r\n\tpublic static Keyboard getMyKeyboard(){\r\n\t\tif (miKeyboard==null){\r\n\t\t\tmiKeyboard = new Keyboard();\r\n\t\t}\r\n\t\treturn miKeyboard;\r\n\t}\r\n\r\n\tpublic int getInt(){\r\n\t\tString auxS = scan.nextLine();\r\n\t\twhile(!this.isNumeric(auxS)){\r\n\t\t\ttry{\r\n\t\t\t\tInteger.parseInt(auxS);\r\n\t\t\t}\r\n\t\t\tcatch (NumberFormatException nfe){\r\n\t\t\t\tSystem.out.println(\"Insert a valid number\");\r\n\t\t\t\tauxS = scan.nextLine();\r\n\t\t\t}\r\n\t\t}\r\n\t\tint resul = Integer.parseInt(auxS);\r\n\t\treturn resul;\r\n\t}\r\n    \r\n\tprivate boolean isNumeric(String cadena){\r\n\t\ttry{\r\n\t\t\tInteger.parseInt(cadena);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tcatch(NumberFormatException nfe){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic String getString(){\r\n\t\tString auxS = scan.nextLine();\r\n\t\treturn auxS;\r\n\t}\r\n}\r\n```\r\n### 5.10 NormalizeStrings\r\n```java\r\npublic class NormalizeStrings extends Thread {\r\n\r\n    private static NormalizeStrings myNormalizeString;\r\n\r\n    public static NormalizeStrings getMyNormalizeString() {\r\n        if (myNormalizeString == null) {\r\n            myNormalizeString = new NormalizeStrings();\r\n        }\r\n        return myNormalizeString;\r\n    }\r\n\r\n    public void run(String[] pLine) {\r\n\r\n        for (int i = 0; i < pLine.length; i++) {\r\n            if (pLine[i].contains(\"Ã¡\")) {\r\n                pLine[i].replaceAll(\"Ã¡\", \"a\");\r\n            } else if (pLine[i].contains(\"Ã©\")) {\r\n                pLine[i].replaceAll(\"Ã©\", \"e\");\r\n            } else if (pLine[i].contains(\"Ã­\")) {\r\n                pLine[i].replaceAll(\"Ã­\", \"i\");\r\n            } else if (pLine[i].contains(\"Ã³\")) {\r\n                pLine[i].replaceAll(\"Ã³\", \"o\");\r\n            } else if (pLine[i].contains(\"Ãº\")) {\r\n                pLine[i].replaceAll(\"Ãº\", \"u\");\r\n            } else if (pLine[i].contains(\"Ã�\")) {\r\n                pLine[i].replaceAll(\"Ã�\", \"A\");\r\n            } else if (pLine[i].contains(\"Ã‰\")) {\r\n                pLine[i].replaceAll(\"Ã‰\", \"E\");\r\n            } else if (pLine[i].contains(\"Ã�\")) {\r\n                pLine[i].replaceAll(\"Ã�\", \"I\");\r\n            } else if (pLine[i].contains(\"Ã“\")) {\r\n                pLine[i].replaceAll(\"Ã“\", \"O\");\r\n            } else if (pLine[i].contains(\"Ãš\")) {\r\n                pLine[i].replaceAll(\"Ãš\", \"U\");\r\n            } else if (pLine[i].contains(\"Ã§\")) {\r\n                pLine[i].replaceAll(\"Ã§\", \"c\");\r\n            } else if (pLine[i].contains(\"Ã\")) {\r\n                pLine[i].replaceAll(\"Ã\", \"a\");\r\n            } else if (pLine[i].contains(\"Ã¨\")) {\r\n                pLine[i].replaceAll(\"Ã¨\", \"e\");\r\n            } else if (pLine[i].contains(\"Ã¬\")) {\r\n                pLine[i].replaceAll(\"Ã¬\", \"i\");\r\n            } else if (pLine[i].contains(\"Ã²\")) {\r\n                pLine[i].replaceAll(\"Ã²\", \"o\");\r\n            } else if (pLine[i].contains(\"Ã¹\")) {\r\n                pLine[i].replaceAll(\"Ã¹\", \"u\");\r\n            } else if (pLine[i].contains(\"Ã€\")) {\r\n                pLine[i].replaceAll(\"Ã€\", \"A\");\r\n            } else if (pLine[i].contains(\"Ãˆ\")) {\r\n                pLine[i].replaceAll(\"Ãˆ\", \"E\");\r\n            } else if (pLine[i].contains(\"ÃŒ\")) {\r\n                pLine[i].replaceAll(\"ÃŒ\", \"I\");\r\n            } else if (pLine[i].contains(\"Ã’\")) {\r\n                pLine[i].replaceAll(\"Ã’\", \"O\");\r\n            } else if (pLine[i].contains(\"Ã™\")) {\r\n                pLine[i].replaceAll(\"Ã™\", \"U\");\r\n            } else if (pLine[i].contains(\"Ã‡\")) {\r\n                pLine[i].replaceAll(\"Ã‡\", \"C\");\r\n            } else if (pLine[i].contains(\"�\")) {\r\n                pLine[i].replaceAll(\"�\", \"A\");\r\n            } else if (pLine[i].contains(\"�s\")) {\r\n                pLine[i].replaceAll(\"�s\", \"Os\");\r\n            }\r\n            this.waitXseconds(0.1);\r\n        }\r\n    }\r\n\r\n    private void waitXseconds(double ms) {\r\n        try {\r\n            Thread.sleep((long)ms * 10);\r\n        } catch (InterruptedException ex) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n### 5.11 StringQuickSort\r\n```java\r\npublic class StringQuickSort {\r\n\r\n    public static void sort(String[] array) {\r\n        sort(array, 0, array.length);\r\n    }\r\n\r\n    private static void sort(String[] array, int fromIndex, int toIndex) {\r\n        if (toIndex - fromIndex < 2) {\r\n            return;\r\n        }\r\n        long timeStart = System.currentTimeMillis();\r\n        sortImpl(array, fromIndex, toIndex, 0);\r\n        long timeTotal = (System.currentTimeMillis() - timeStart);\r\n        System.out.println(\"\\t\\t --- Elapsed time to order the actor list --- : \" + (int) timeTotal / 1000 + \"sec, \" + timeTotal * 1000 + \"ms\\n\");\r\n    }\r\n\r\n    private static void sortImpl(String[] array, int fromIndex, int toIndex, int stringLength) throws NullPointerException {\r\n\r\n\r\n\r\n        int rangeLength = toIndex - fromIndex;\r\n\r\n        if (rangeLength < 2) {\r\n            return;\r\n        }\r\n\r\n        int finger = fromIndex;\r\n\r\n        // Put all strings of length 'stringLength' to the beginning of the\r\n        // requested sort range.\r\n        for (int index = fromIndex; index < toIndex; ++index) {\r\n            String current = array[index];\r\n            if (current.length() == stringLength) {\r\n                String tmp = array[finger];\r\n                array[finger] = current;\r\n                array[index] = tmp;\r\n                ++finger;\r\n            }\r\n        }\r\n\r\n        fromIndex = finger;\r\n\r\n        // Choose a pivot string by median.\r\n        String probeLeft = array[fromIndex];\r\n        String probeRight = array[toIndex - 1];\r\n        String probeMiddle = array[fromIndex + rangeLength >> 1];\r\n\r\n        String pivot = median(probeLeft, probeMiddle, probeRight);\r\n\r\n        // Process strings S for which S[stringLength] < X[stringLength].\r\n        for (int index = fromIndex; index < toIndex; ++index) {\r\n            String current = array[index];\r\n\r\n            if (current.charAt(stringLength) < pivot.charAt(stringLength)) {\r\n                String tmp = array[finger];\r\n                array[finger] = current;\r\n                array[index] = tmp;\r\n                ++finger;\r\n            }\r\n        }\r\n\r\n        sortImpl(array, fromIndex, finger, stringLength);\r\n\r\n        fromIndex = finger;\r\n\r\n        for (int index = fromIndex; index < toIndex; ++index) {\r\n            String current = array[index];\r\n\r\n            if (current.charAt(stringLength) == pivot.charAt(stringLength)) {\r\n                String tmp = array[finger];\r\n                array[finger] = current;\r\n                array[index] = tmp;\r\n                ++finger;\r\n            }\r\n        }\r\n\r\n        sortImpl(array, fromIndex, finger, stringLength + 1);\r\n        sortImpl(array, finger, toIndex, stringLength);\r\n    }\r\n\r\n    private static String median(String a, String b, String c) {\r\n        if (a.compareTo(b) <= 0) {\r\n            if (c.compareTo(a) <= 0) {\r\n                return a;\r\n            }\r\n            return b.compareTo(c) <= 0 ? b : c;\r\n        }\r\n\r\n        if (c.compareTo(b) <= 0) {\r\n            return b;\r\n        }\r\n        return a.compareTo(c) <= 0 ? a : c;\r\n    }\r\n\r\n}\r\n```\r\n### 5.12 SwingGUI\r\n```java\r\npublic class SwingGUI extends javax.swing.JFrame {\r\n\r\n    private static SwingGUI myJMenu;\r\n    private javax.swing.JButton button1;\r\n    private javax.swing.JButton button2;\r\n    private javax.swing.JTextField button2textField;\r\n    private javax.swing.JButton button3;\r\n    private javax.swing.JTextField button3textField;\r\n    private javax.swing.JButton button4;\r\n    private javax.swing.JTextField button4textField;\r\n    private javax.swing.JButton button5;\r\n    private javax.swing.JTextField button5textField;\r\n    private javax.swing.JButton button6;\r\n    private javax.swing.JTextField button6textField;\r\n    private javax.swing.JButton button7;\r\n    private javax.swing.JTextField button7textField;\r\n    private javax.swing.JButton button8;\r\n    private javax.swing.JButton button9;\r\n    private javax.swing.JLabel jLabel1;\r\n    private javax.swing.JLabel jLabel10;\r\n    private javax.swing.JLabel jLabel2;\r\n    private javax.swing.JLabel jLabel3;\r\n    private javax.swing.JLabel jLabel4;\r\n    private javax.swing.JLabel jLabel5;\r\n    private javax.swing.JLabel jLabel6;\r\n    private javax.swing.JLabel jLabel7;\r\n    private javax.swing.JLabel jLabel8;\r\n    private javax.swing.JLabel jLabel9;\r\n    private javax.swing.JProgressBar jProgressBar;\r\n\r\n    /**\r\n     * Creates new form SwingGUI\r\n     */\r\n    public SwingGUI() {\r\n        initComponents();\r\n    }\r\n\r\n    public static SwingGUI getMyJMenu() {\r\n        if (myJMenu == null) {\r\n            myJMenu = new SwingGUI();\r\n        }\r\n        return myJMenu;\r\n    }\r\n\r\n    /**\r\n     * This method is called from within the constructor to initialize the form.\r\n     * WARNING: Do NOT modify this code. The content of this method is always\r\n     * regenerated by the Form Editor.\r\n     */\r\n    private void initComponents() {\r\n\r\n        jLabel1 = new javax.swing.JLabel();\r\n        button1 = new javax.swing.JButton();\r\n        button2 = new javax.swing.JButton();\r\n        button3 = new javax.swing.JButton();\r\n        jLabel2 = new javax.swing.JLabel();\r\n        jLabel3 = new javax.swing.JLabel();\r\n        jLabel4 = new javax.swing.JLabel();\r\n        button4 = new javax.swing.JButton();\r\n        jLabel5 = new javax.swing.JLabel();\r\n        button5 = new javax.swing.JButton();\r\n        jLabel6 = new javax.swing.JLabel();\r\n        button6 = new javax.swing.JButton();\r\n        jLabel7 = new javax.swing.JLabel();\r\n        button7 = new javax.swing.JButton();\r\n        jLabel8 = new javax.swing.JLabel();\r\n        button8 = new javax.swing.JButton();\r\n        jLabel9 = new javax.swing.JLabel();\r\n        button9 = new javax.swing.JButton();\r\n        jLabel10 = new javax.swing.JLabel();\r\n        jProgressBar = new javax.swing.JProgressBar();\r\n        button2textField = new javax.swing.JTextField();\r\n        button3textField = new javax.swing.JTextField();\r\n        button4textField = new javax.swing.JTextField();\r\n        button5textField = new javax.swing.JTextField();\r\n        button6textField = new javax.swing.JTextField();\r\n        button7textField = new javax.swing.JTextField();\r\n\r\n        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\r\n\r\n        jLabel1.setFont(new java.awt.Font(\"Lucida Grande\", 1, 14)); // NOI18N\r\n        jLabel1.setText(\"IMDb Actor/Movie Catalog - EDA16-17-  \");\r\n\r\n        button1.setText(\"(1)\");\r\n        button1.addActionListener(evt -> button1ActionPerformed());\r\n\r\n        button2.setText(\"(2)\");\r\n        button2.addActionListener(new java.awt.event.ActionListener() {\r\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\r\n                button2ActionPerformed();\r\n            }\r\n        });\r\n\r\n        button3.setText(\"(3)\");\r\n        button3.addActionListener(evt -> button3ActionPerformed());\r\n\r\n        jLabel2.setText(\"Read data from file\");\r\n\r\n        jLabel3.setText(\"Search for an actor/actress\");\r\n\r\n        jLabel4.setText(\"Add a new actor/actress\");\r\n\r\n        button4.setText(\"(4)\");\r\n        button4.addActionListener(evt -> button4ActionPerformed());\r\n\r\n        jLabel5.setText(\"Search for films of a particular actor\");\r\n\r\n        button5.setText(\"(5)\");\r\n        button5.addActionListener(evt -> button5ActionPerformed());\r\n\r\n        jLabel6.setText(\"Search for actors of a particular film\");\r\n\r\n        button6.setText(\"(6)\");\r\n        button6.addActionListener(evt -> button6ActionPerformed());\r\n\r\n\r\n        jLabel7.setText(\"Increase the money raised by a film\");\r\n\r\n        button7.setText(\"(7)\");\r\n        button7.addActionListener(evt -> button7ActionPerformed());\r\n\r\n        jLabel8.setText(\"Erase an actor/actress\");\r\n\r\n        button8.setText(\"(8)\");\r\n        button8.addActionListener(evt -> button8ActionPerformed());\r\n\r\n        jLabel9.setText(\"Obtain an ordered list of actors (name, surname)\");\r\n\r\n        button9.setText(\"(9)\");\r\n        button9.addActionListener(evt -> button9ActionPerformed());\r\n\r\n        jLabel10.setText(\"Save/Export the list to a file\");\r\n\r\n        button2textField.setText(\"Actor/Actress name to search for\");\r\n\r\n        button3textField.setText(\"Actor/Actress name to add\");\r\n\r\n        button4textField.setText(\"Name of the film\");\r\n\r\n        button5textField.setText(\"Name of the actor/actress\");\r\n\r\n        button6textField.setText(\"Amount of money to increase\");\r\n        button6textField.setVisible(false);\r\n\r\n        button7textField.setText(\"Actor/Actress name to delete\");\r\n\r\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\r\n        getContentPane().setLayout(layout);\r\n        layout.setHorizontalGroup(\r\n                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\r\n                        .addGroup(layout.createSequentialGroup()\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\r\n                                        .addGroup(layout.createSequentialGroup()\r\n                                                .addGap(106, 106, 106)\r\n                                                .addComponent(jLabel1))\r\n                                        .addGroup(layout.createSequentialGroup()\r\n                                                .addContainerGap()\r\n                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\r\n                                                        .addComponent(button9, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button8, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button7, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button6, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button5, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel2)\r\n                                                                .addGap(18, 18, 18)\r\n                                                                .addComponent(jProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 167, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel3)\r\n                                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\r\n                                                                .addComponent(button2textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel4)\r\n                                                                .addGap(18, 18, 18)\r\n                                                                .addComponent(button3textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel5)\r\n                                                                .addGap(18, 18, 18)\r\n                                                                .addComponent(button4textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel6)\r\n                                                                .addGap(18, 18, 18)\r\n                                                                .addComponent(button5textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel7)\r\n                                                                .addGap(18, 18, 18)\r\n                                                                .addComponent(button6textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel8)\r\n                                                                .addGap(18, 18, 18)\r\n                                                                .addComponent(button7textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addComponent(jLabel9)\r\n                                                        .addComponent(jLabel10))))\r\n                                .addContainerGap(34, Short.MAX_VALUE))\r\n        );\r\n        layout.setVerticalGroup(\r\n                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\r\n                        .addGroup(layout.createSequentialGroup()\r\n                                .addContainerGap()\r\n                                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)\r\n                                .addGap(18, 18, 18)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\r\n                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                                .addComponent(button1)\r\n                                                .addComponent(jLabel2))\r\n                                        .addComponent(jProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button2)\r\n                                        .addComponent(jLabel3)\r\n                                        .addComponent(button2textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button3)\r\n                                        .addComponent(jLabel4)\r\n                                        .addComponent(button3textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button4)\r\n                                        .addComponent(jLabel5)\r\n                                        .addComponent(button4textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button5)\r\n                                        .addComponent(jLabel6)\r\n                                        .addComponent(button5textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button6)\r\n                                        .addComponent(jLabel7)\r\n                                        .addComponent(button6textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button7)\r\n                                        .addComponent(jLabel8)\r\n                                        .addComponent(button7textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button8)\r\n                                        .addComponent(jLabel9))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button9)\r\n                                        .addComponent(jLabel10))\r\n                                .addContainerGap(12, Short.MAX_VALUE))\r\n        );\r\n\r\n        pack();\r\n    }\r\n\r\n    private void button1ActionPerformed( ) {\r\n        try {\r\n            jProgressBar.setMinimum(0);\r\n            jProgressBar.setMaximum(100);\r\n            FileManager.getMyFileManager().readFile(1);\r\n        } catch (FileNotFoundException e1) {\r\n            System.out.println(\"File not found. ¿Are you sure that you're opening the correct file?\");\r\n        } catch (IOException e2) {\r\n            System.out.println(\"IOException when counting lines for the progress bar\");\r\n        }\r\n\r\n    }\r\n\r\n    private void button2ActionPerformed() {\r\n        String auxActorName = button2textField.getText();\r\n        String[] auxActorArray = auxActorName.split(\"\\\\s\");\r\n        auxActorName = auxActorArray[0];\r\n        String auxActorSurname = auxActorArray[1];\r\n        Actor auxActor = new Actor(auxActorName, auxActorSurname);\r\n        Actor actor = ActorCatalog.getmyActorCatalog().searchActor(auxActor);\r\n        if (actor != null) {\r\n            System.out.println(\"Actor finded. \" + actor.getName() + \" \" + actor.getSurname());\r\n        } else {\r\n            System.out.println(\"Actor: \" + button2textField.getText() + \" not found\");\r\n        }\r\n    }\r\n\r\n    private void button3ActionPerformed() {\r\n        String auxActorName = button3textField.getText();\r\n        String[] auxActorArray = auxActorName.split(\"\\\\s\");\r\n        auxActorName = auxActorArray[0];\r\n        String auxActorSurname = auxActorArray[1];\r\n        Actor auxActor = new Actor(auxActorName, auxActorSurname);\r\n        if (ActorCatalog.getmyActorCatalog().searchActor(auxActor) != null) {\r\n            System.out.println(\"Actor already exists\");\r\n        } else {\r\n            ActorCatalog.getmyActorCatalog().addActor(auxActor);\r\n        }\r\n    }\r\n\r\n    private void button4ActionPerformed() {\r\n        String auxActorName = button4textField.getText();\r\n        String[] auxActorArray = auxActorName.split(\"\\\\s\");\r\n        auxActorName = auxActorArray[0];\r\n        String auxActorSurname = auxActorArray[1];\r\n        Actor auxActor = new Actor(auxActorName, auxActorSurname);\r\n        if (ActorCatalog.getmyActorCatalog().searchActor(auxActor) != null) {\r\n            ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)).getFilmList().printFilms();\r\n        } else {\r\n            System.out.println(\"Not posible to erase. Actor doesn't exist\");\r\n        }\r\n\r\n    }\r\n\r\n    private void button5ActionPerformed() {\r\n        String auxFilmName = button5textField.getText();\r\n        if (FilmCatalog.getMyFilmCatalog().getFilm(auxFilmName) != null) {\r\n            FilmCatalog.getMyFilmCatalog().getFilm(auxFilmName).getActorList().printActors();\r\n        }\r\n    }\r\n\r\n    private void button6ActionPerformed() {\r\n        JTextField filmName = new JTextField(15);\r\n        JTextField moneyQuantity = new JTextField(15);\r\n\r\n        JPanel myPanel = new JPanel();\r\n        myPanel.add(new JLabel(\"Film name:\"));\r\n        myPanel.add(filmName);\r\n        myPanel.add(Box.createHorizontalStrut(15)); // a spacer\r\n        myPanel.add(new JLabel(\"Money quantity:\"));\r\n        myPanel.add(moneyQuantity);\r\n\r\n        JOptionPane.showConfirmDialog(null, myPanel,\r\n                \"Please enter filmName and moneyQuantity values\", JOptionPane.OK_CANCEL_OPTION);\r\n        try {\r\n            FilmCatalog.getMyFilmCatalog().getFilm(filmName.getText()).incrementEarned(Integer.parseInt(moneyQuantity.getText()));\r\n            System.out.println(\"Total earned by the film: \" + FilmCatalog.getMyFilmCatalog().getFilm(filmName.getText()).getEarned());\r\n        } catch (NullPointerException e1) {\r\n            System.out.println(\"File not found or invalid moneyQuantity\");\r\n        }\r\n    }\r\n\r\n    private void button7ActionPerformed() {\r\n        String auxActorName = button7textField.getText();\r\n        String[] auxActorArray = auxActorName.split(\"\\\\s\");\r\n        auxActorName = auxActorArray[0];\r\n        String auxActorSurname = auxActorArray[1];\r\n        try {\r\n            ActorCatalog.getmyActorCatalog().removeActor(new Actor(auxActorName, auxActorSurname));\r\n        } catch (NullPointerException e1) {\r\n            System.out.println(\"Actor not found\");\r\n        }\r\n    }\r\n\r\n    private void button8ActionPerformed() {\r\n        ActorCatalog.getmyActorCatalog().quickSortList();\r\n    }\r\n\r\n    private void button9ActionPerformed() {\r\n        try {\r\n            FileManager.getMyFileManager().exportToFile();\r\n        } catch (Exception e1) {\r\n            System.out.println(\"Error during operation\");\r\n        }\r\n    }\r\n\r\n    public void updateBar(int pNewValue) {\r\n        jProgressBar.setValue(pNewValue);\r\n    }\r\n}\r\n```\r\n### 5.13 TerminalGUI\r\n```java\r\npublic class TerminalUI {\r\n\r\n    private static TerminalUI myTerminalGUI;\r\n    private Scanner optMenu;\r\n\r\n    private TerminalUI() {\r\n        optMenu = new Scanner(System.in);\r\n    }\r\n\r\n    public static TerminalUI getMyTerminalGUI() {\r\n        if (myTerminalGUI == null) {\r\n            myTerminalGUI = new TerminalUI();\r\n        }\r\n        return myTerminalGUI;\r\n    }\r\n\r\n    public static void main() throws FileNotFoundException {\r\n\r\n        String[] auxActorArray;\r\n        String auxActorName;\r\n        String auxActorSurname;\r\n\r\n        String auxS;\r\n\r\n        System.out.println(\"\\t\\t\\t***-----Welcome to our IMDb EDA16/17 project menu-----***\");\r\n\r\n        do {\r\n            System.out.println(\"\\n\\t\\t\\t----------MENU----------\");\r\n            System.out.println(\"\\t\\t1) Read data from file\");\r\n            System.out.println(\"\\t\\t2) Search for an actor/actress\");\r\n            System.out.println(\"\\t\\t3) Add a new actor/actress\");\r\n            System.out.println(\"\\t\\t4) Search for films of a particular actor\");\r\n            System.out.println(\"\\t\\t5) Search for actor of a particular film\");\r\n            System.out.println(\"\\t\\t6) Increase the money raised by a film\");\r\n            System.out.println(\"\\t\\t7) Erase an actor/actress\");\r\n            System.out.println(\"\\t\\t8) Obtain an ordered list of actor (name,surname)\");\r\n            System.out.println(\"\\t\\t9) Save/Export the new list to a file\");\r\n\r\n            int optMenu = Keyboard.getMyKeyboard().getInt();\r\n\r\n            switch (optMenu) {\r\n                case 0:\r\n                    System.out.println(\"\\t\\t--- Saliendo del programa... ----\");\r\n                    break;\r\n                case 1:\r\n                    try {\r\n                        System.out.println(\"\\tSelect one of options below: \");\r\n                        System.out.println(\"\\t\\t1) Read only the 'readable' actors/films (after trying to rescue some names from the codification, take only the 'full readables') \");\r\n                        System.out.println(\"\\t\\t2) Read the full list of actors/movies (don't care if they're wrong written, after running our conversor\");\r\n                        int optMenu1 = 0;\r\n                        while (optMenu1 < 1 || optMenu1 > 2) {\r\n                            optMenu1 = Keyboard.getMyKeyboard().getInt();\r\n                            if (optMenu1 == 1) {\r\n                                FileManager.getMyFileManager().readFile(1);\r\n                            } else if (optMenu1 == 2) {\r\n                                FileManager.getMyFileManager().readFile(2);\r\n                            } else {\r\n                                System.out.println(\"Invalid option, try again. Select a number between 1-2 range\");\r\n                            }\r\n                        }\r\n\r\n                    } catch (FileNotFoundException e1) {\r\n                        System.out.println(\"File not found. ¿Are you sure that you're opening the correct file?\");\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    System.out.println(\"Enter the name of the actor you want to look for: \");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    auxActorArray = auxS.split(\"\\\\s\");\r\n                    auxActorName = auxActorArray[0];\r\n                    auxActorSurname = auxActorArray[1];\r\n                    Actor auxA = ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname));\r\n                    if (auxA == null) {\r\n                        System.out.println(\"Actor not finded: \" + auxS);\r\n                    } else {\r\n                        System.out.println(\"Actor finded: \" + auxA.getName());\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    System.out.println(\"Enter the name of the actor that you want to add: \");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    auxActorArray = auxS.split(\"\\\\s\");\r\n                    auxActorName = auxActorArray[0];\r\n                    auxActorSurname = auxActorArray[1];\r\n                    if (ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)) != null) {\r\n                        System.out.println(\"Actor: \" + auxS + \" already exist\");\r\n                    } else {\r\n                        ActorCatalog.getmyActorCatalog().addActor(new Actor(auxActorName, auxActorSurname));\r\n                        System.out.println(\"Actor: \" + auxS + \" added to the ActorCatalog\");\r\n                    }\r\n                    break;\r\n                case 4:\r\n                    System.out.println(\"Enter the name of the actor whose films you want to know\");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    auxActorArray = auxS.split(\"\\\\s\");\r\n                    auxActorName = auxActorArray[0];\r\n                    auxActorSurname = auxActorArray[1];\r\n                    if (ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)) != null) {\r\n                        ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)).getFilmList().printFilms();\r\n                    } else {\r\n                        System.out.println(\"Actor: \" + auxS + \" do not exist in the ActorCatalog\");\r\n                    }\r\n                    break;\r\n                case 5:\r\n                    System.out.println(\"Enter the film whose actors that do you want to know: \");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    if (FilmCatalog.getMyFilmCatalog().getFilm(auxS) != null) {\r\n                        FilmCatalog.getMyFilmCatalog().getFilm(auxS).getActorList().printActors();\r\n                    }\r\n                    break;\r\n                case 6:\r\n                    System.out.println(\"Enter the film whose amount of earning you want to raise: \");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    System.out.println(\"Enter the amount of money that you want to increase: \");\r\n                    int auxI = Keyboard.getMyKeyboard().getInt();\r\n                    if (FilmCatalog.getMyFilmCatalog().exist(auxS)) {\r\n                        FilmCatalog.getMyFilmCatalog().getFilm(auxS).incrementEarned(auxI);\r\n                        System.out.println(\"Total earned by the film: \" + FilmCatalog.getMyFilmCatalog().getFilm(auxS).getEarned());\r\n                    } else {\r\n                        System.out.println(\"File not found. Are you sure that you have written title correctly?\");\r\n                    }\r\n                    break;\r\n                case 7:\r\n                    System.out.println(\"Enter the name of the actor that you want to remove\");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    auxActorArray = auxS.split(\"\\\\s\");\r\n                    auxActorName = auxActorArray[0];\r\n                    auxActorSurname = auxActorArray[1];\r\n                    if (ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)) != null) {\r\n                        ActorCatalog.getmyActorCatalog().removeActor(new Actor(auxActorName, auxActorSurname));\r\n                        System.out.println(\"Actor: \" + auxS + \" succesfully removed\");\r\n                    } else {\r\n                        System.out.println(\"Actor: \" + auxS + \" do not exist in the ActorCatalog\");\r\n                    }\r\n                    break;\r\n                case 8:\r\n                    ActorCatalog.getmyActorCatalog().quickSortList();\r\n                    break;\r\n                case 9:\r\n                    FileManager.getMyFileManager().exportToFile();\r\n                    break;\r\n            }\r\n        } while (1 != 0);\r\n    }\r\n}\r\n```\r\n### 6. Resultados de las pruebas\r\n\r\n**Estos son los resultados de las pruebas**, en la etapa final de desarrollo (lo que estamos entregando) de la actividad. **Todos los tiempos que mostramos son medias** realizadas (entre 5-10 ejecuciones) **de la misma operación**. Las pruebas **se han realizado en diferentes equipos con diferentes sistemas operativos**, detallamos:\r\n\r\nEn el fichero normalizado encontramos **1 061 522** actores, **230 369** peliculas.\r\nEn el fichero sin normalizar (cogiento toda la informacion, independientemente de si estan bien escritos) encontramos **1 191 316** actores, **238 809** peliculas.\r\n\r\n- **CPU**: Intel i5 6600K 3,9 GHz x 4 cores, **GPU:** nVidia GTX 970 4GB Strix,**RAM:** 16GB DDR5  2666, **SO:** *Windows 10 Pro x64*\r\n\t- Cargar fichero normalizado: \r\n\t- Cargar fichero completo: \r\n\t- Ordenar lista normalizada de actores: \r\n\t- Ordenar lista completa de actores: \r\n\t- Exportar lista normalizada de actores: \r\n\t- Exportar lista completa de actores: \r\n\r\n- **CPU**: Intel i5 2,7 GHz x 2 cores, **GPU:** HD 6100,**RAM:** 8GB LPDDR3  1866, **SO:** *Mac OS Sierra (10.12)*\r\n\t- Cargar fichero normalizado: 20sec\r\n\t- Cargar fichero completo: 26sec\r\n\t- Ordenar lista normalizada de actores: 1sec, 1398000ms\r\n\t- Ordenar lista completa de actores: 1sec, 1376000ms\r\n\t- Exportar lista normalizada de actores: 12sec, 12976000ms\r\n\t- Exportar lista completa de actores: 21sec, 21158000ms\r\n\r\n- **CPU**: Intel Atom Z3775 1,46 GHz x 2 cores, **GPU:** Intel HD Graphics (Bay Trail) (311 - 778 MHz),**RAM:** 2GB RAM 1333, **SO:** *Windows 10 Home x32*\r\n\t- Cargar fichero normalizado: 90sec\r\n\t- Cargar fichero completo: El ordenador no es capaz de leerlo\r\n\t- Ordenar lista normalizada de actores: 2sec, 2312000ms\r\n\t- Ordenar lista completa de actores: No es capaz de leer el fichero completo\r\n\t- Exportar lista normalizada de actores: 78sec, 78051000ms\r\n\t- Exportar lista completa de actores: No es posible leer el fichero completo\r\n\r\n- **CPU**: AMD FX 6300 3,5 GHz x 6 cores, **GPU:** AMD Shappire R7 370 4GB,**RAM:** 16 GB DDR3 1600, **SO:** *Windows Pro x64*\r\n\t- Cargar fichero normalizado: 90sec\r\n\t- Cargar fichero completo: El ordenador no es capaz de leerlo\r\n\t- Ordenar lista normalizada de actores: 2sec, 2312000ms\r\n\t- Ordenar lista completa de actores: No es capaz de leer el fichero completo\r\n\t- Exportar lista normalizada de actores: 78sec, 78051000ms\r\n\t- Exportar lista completa de actores: No es posible leer el fichero completo\r\n\r\n### 7. Conclusiones\r\n\r\nDestacamos como bien hemos indicado, l**a importancia de las búsquedas en el funcionamiento de nuestro programa**. Al tener que trabajarlas tanto, es necesario optimizarlas al máximo para evitar tiempos de ejecución demasiado altos.\r\n\r\n**Otro de los métodos con mucha importancia es cargarFichero()** dado que coge línea a línea el texto que hay en el fichero y lo trata. Es decir, elimina toda la información no relevante para el programa y añade la que si tiene importancia.\r\nMientras trabajamos, como ya hemos comentado, **hicimos una version del programa que trabajaba con búsquedas dicotómicas y el resultado de la experiencia fue darnos cuenta de cuanta importancia podía llegar a tener el mantener la lista ordenada** para evitar usar búsquedas lineales y que el tiempo de ejecución se volviera a disparar.\r\n\r\n**Tras analizar el fichero y destacar un patrón que pudiera servirnos** para, basandonos en el metodo split (de la clase String), separar las lineas del documento en información que nos fuera mas sencilla de manejar; **nos centramos en optimizar al máximo el funcionamiento de esta carga**.\r\nPara realizar la operacion de una forma mas transparente al usuario y sin saturar la ventana de la consola,** hemos desarrollado un metodo que calcula el procentaje actual del documento y la imprime por pantalla en bloques de 10% en 10%** y sin repetirse ninguna de las impresiones.\r\nAsí mismo, **hemos implementado programación basada en multiples procesos para aligerar la carga del fichero con la opción de normalización de nombres que hemos decidido aportar**. Las diferencias las detallaremos ahora con mas datos.\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}