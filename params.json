{
  "name": "Eda16-17",
  "tagline": "Contains all practical course deliveries for the subject \"Estructuras de Datos y Algoritmos\" from the college \"UPV/EHU EUITI Bilbao\"",
  "body": "#Practica. Actividad 1.\r\n\t\t\t\tUPV-EHU 2016/2017\r\n                            \r\n                            \r\n                            \r\n                Estructuras de Datos y Algoritmos\r\n                          \r\n\r\n              \r\n              \r\n                \r\n                \r\n                \t\t\t\t\t\t\t\t\t\t\tJosu Alvarez\r\n                                                            David Max\r\n\r\n* * * *\r\n##Indice\r\n\r\nMas informacion en la pagina web del proyecto: \r\n[TOC]\r\n\r\n* * *\r\n\r\n##1. Introducción\r\n\r\n**Dado un fichero de datos** que contiene actores y actrices de Internet Movie DataBase (IMDB), con una estructura efinida ('nombrePelicula' ---> 'nombreActor1' &&& 'nombreActor2'...) . **Se ha de implementar un programa que cargue el fichero de datos y extraiga del mismo los nombres de los actores y las peliculas que contiene**.\r\n\r\n**El pilar del funcionamiento de nuestro programa son las búsquedas**. Dado que tanto para añadir, eliminar como para gestionar alguno de los datos previamente se hará una búsqueda para comprobar si realmente existe.\r\n\r\nDado que disponiamos de tiempo y que el proyecto nos ha parecido interesante, **hemos decidido implementar ciertas mejoras sobre el trabajo inicial**, siendo estas:\r\n\r\n- ** El sistema dará la opción** al usuario para que decida como quiere ejecutar el programa, si por la **consola o bien mediante una GUI** que hemos construido con Swing.\r\n- **Hay dos formas de cargar el archivo**, una **con todos los datos y** otra **con los datos normalizados** (se explica mejor en las proximas lineas).\r\n- **Todo el proyecto** y todas sus versiones estan **siendo manejadas mediante GitHub**, se ha dispuesto una pagina web publica que contiene esta misma información y será actualizada con cada una de las proximas entregas.\r\n- **Uso exclusivo de lenguaje 'Markdown' para proceder a documentar el codigo**. En nuestro esfuerzo por usar tecnologías libres y ser eficientes, hemos encontrado este lenguaje ideal (dada su total compatibilidad con las wikis y las webs de GitHub).\r\n- **Uso del ingles** siempre que nos ha sido posible, para desarrollar el codigo de forma universal y que cualquier programador interesado lo pueda revisar, utilizar o mejorar desde el GitHub habilitado para ello.\r\n\r\n**Hemos definido que el programa cumpla** las siguientes funciones:\r\n\r\n1. ***Carga de datos desde fichero:* ** Se dará a elegir al usuario si quiere cargar la lista completa o solo querrá cargar los actores/peliculas que se encuentren bien escritos, es decir, que sean legibles tras haber sido tratados con un método que hemos establecido para normalizar nombres en base a caracteres desconocidos.\r\n1. ***Búsqueda de un actor/película:* ** Devolvera el actor en caso de existir, en caso contrario dará un aviso por terminal/pop-up.\r\n1. ***Inserción de un actor/película:* ** Indica si ha sido posible añadir el actor o si el mismo existía previamente.\r\n1. ***Eliminación de un actor/película:* ** Indica si el actor existe y en ese caso, que ha sido borrado. En caso contrario informará de que no existe.\r\n1. ***Obtener la lista de peliculas de un actor:* * ** Comprueba que el actor exista, y en caso positivo, muestra la lista de peliculas del mismo\r\n1. ***Obtener la lista de actores de una pelicula (reparto):* **  Comprobamos que la pelicula existe previamente y en caso positivo, imprimimos por pantalla los actores que la componen. En caso de no existir, se informará de dicha situación al usuario.\r\n1. ***Modificar el presupuesto de una pelicula:* ** Comprobamos que la pelicula introducida existe previamente y si es así, incrementamos el valor de recaudación en X (donde X es el valor introducido por el usuario). En caso de no existir la pelicula, se informará de dicha siatuación al usuario.\r\n1. ***Obtener una lista de actores ordenada (nombre, apellido):* ** Obtenemos una lista de actores ordenados bajo el criterio: Nombre Apellido (separados unicamente por un espacio)\r\n1. ***Exportar los datos a un fichero de texto:* ** Exportamos la lista ordenada de los actores, con sus respetivas peliculas a un fichero de texto `.txt`\r\n\r\n\r\n* * *\r\n\r\n## 2. Diagrama de clases\r\n\r\nEste es el diseño final del programa, los diseños iniciales y la evolución de los mismos hasta llegar a esta se encuentran en nuestro GitHub.\r\n\r\n![](/Users/Josu/IdeaProjects/EDA16-17/src/lab1/diagram.png)\r\n\r\n\r\n* * *\r\n\r\n\r\n## 3. Descripción de las estructuras de datos principales\r\n\r\nComo comentábamos en la introducción del documento, **la parte más importante** del documento recae en los métodos que realizan **las búsquedas**. Dado que **son necesarios para trabajar la información, añadir y eliminarla**.\r\n\r\nPara trabajar las búsquedas **inicialmente lo hacíamos mediante búsquedas lineales**, pero viendo que **el coste del mismo se disparaba al trabajar con grandes cantidades de datos**; **decidimos optar por usar el algoritmo de búsqueda binaria** (que solo funciona si la lista esta previamente ordenada). La **búsqueda lineal tenía un coste de *O(n)* mientras que la dicotómica/binaria *O(log n)* **.\r\n**Finalmente, vimos que podriamos tratar las búsquedas casi como un coste constante** si utilizabamos alguna estructura de datos de la familia **'Map'**. Por eso, replanteamos el diseño del programa e **hicimos que todas las estructuras de datos con las que trabajamos sean *HashMap < String, T >* ** donde 'T' es cualquier objeto que necesitemos almacenar (peliculas, actores...).\r\n\r\nTeniendo en cuenta que:\r\n- **n** es el numero de peliculas que hay en el fichero\r\n- **m** es el numero de actores que por pelicula del fichero (n)\r\n\r\n**Utilizando HashMap como estructura** de datos contenedora, el proceso de **cargar el fichero tiene un coste de *O(n*m)* **.Por un lado recorremos completamente el fichero de datos y por otro, tenemos que recorrer completamente la lista que estamos creando e inicializando con los datos del fichero. Al hacerlo mediante un hashmap, nos ahorramos la variable ‘p’ en el coste, dado que no tenemos que recorrer la listaAux (por que es un hashmap).\r\n\r\nComo **algoritmo de ordenación**, utilizábamos BubbleSort. Este, habia sido el algoritmo con el que mas habíamos trabajo y con el que mas cómodos nos sentiamos, pero al igual que en el anterior caso, decidimos hacer modificaciones debido a que su coste era demasiado alto para lo que buscábamos O(n2). Hicimos distintas pruebas con MergeSort, aunque **finalmente optamos como algoritmo por el QuickSort reduciendo así el coste hasta O(n* log n)**.\r\nPara realizar **la operación de ordenación**, previamente **volcamos las claves de nuestro HashMap** (que son los nombres de los actores) **en un Array[] de String y procedemos a ordenarlo**. **Tras esto, recibiremos una lista de claves ordenadas**, que en caso de querer mostrar unicamente los nombres de los actores cumple al 100% la función y en caso de querer mostrar mas información, lo recorreremos en orden y accederemos con cada clave a la información de nuestro catálogo (HashMap).\r\n\r\n## 4. Diseño e implementacion de los metodos principales\r\n\r\nEste apartado lo dedicaremos a explicar el funcionamiento de diferentes métodos principales, así como: readFile(), addActor(), removeActor(), searchActor() y quickSortList().\r\n\r\n###4.1. readFile():\r\n\r\n####4.1.1 Precondicion/Postcondicion\r\n++Precondicion:++ Tendremos un fichero\r\n++Postcondicion:++ El programa habra leido el fichero\r\n\r\n####4.1.2 Casos de prueba\r\n* Archivo null\r\n* Archivo correcto\r\n * Tras analizar el fichero, asumimos la posicion predefinida de los caracteres especiales.\r\n\r\n####4.1.3 Coste\r\n\r\nInicialmente deficimos hacer la lectura del fichero con un FileReader, pero acabamos viendo que no era eficiente (tiempos medios de 90s), también probamos con el metodo readAllLines() y volcarlo sobre una lista (34s aprox.), pero finalmente hemos optado por volcar en una lista (List< String >) el contenido de un BuffererReader e iterar sobre el con un *for* hasta llegar al final del documento a leer.\r\n\r\nEste algoritmo tratara de leer un fichero .txt en el que aparecen nombres de peliculas, y los actores que participan en ellas. Por ello, el programa estimamos que tendrá un coste de ***O(n x m)* **, donde n es la cantidad de actores, y m es la cantidad de peliculas.\r\n\r\n####4.1.4 Pseudo-algoritmo\r\n\r\n\t\tnew BufferedReader(FileReaderDelFicheroQueQueremosLeer)\r\n        contLineas = contadorLineas(nuevo File(\"Direccion\"))\r\n        auxCont = 0\r\n\r\n\t\tmientras siguienteLinea != null\r\n        \tguardamos en auxLinea1 = siguienteLinea.split (\" ---> \") la linea separadas \t\t  \ten: nombre de pelicula y actores\r\n        \tsi opcion == 1 entonces\r\n    \t   \tNormalizamos()\r\n\t\t\tfin si\r\n        \tnombrePelicula = auxLinea1[0]\r\n\t\t\tguardamos en auxLine2 = auxLinea1[1].split(\" &&& \") los nombres de los \t\t\t actores que participan en la pelicula en cuestión.\r\n        \tcreamos auxFilm = Film(nombrePelicula)\r\n       \t CatalogoPeliculas.getMiCatalogoPeliculas().añadirPelicula(auxFilm)\r\n    \t    creamos varable temporal i = 0 como contador\r\n     \t   mientras(auxLine2.lenght > i)\r\n      \t  \tnombreActor = auxLine2[i]\r\n        \t    apellidoActor = \"\"\r\n            \tsi (nombreActor.contiene(\"(\")) entonces\r\n            \t\tauxLinea1 = nombreActor.split(\" (\")\r\n                \tnombreActor = auxLinea1[0]\r\n           \t fin si\r\n            \tsi (nombreActor.contiene(\",\")) entonces\r\n            \t\tauxLinea1 = nombreActor.split(\", \")\r\n                \tsi(auxLinea1.length > 1) entonces\r\n                    \tsi(auxLinea1[1].comparar(\"null\") != 0) entonces\r\n                        \tapellidoActor = auxLinea1[0]\r\n                            nombreActor = auxLinea1[1]\r\n                        si no\r\n                        \tnombreActor = auxLinea[0]\r\n                        fin si\r\n                   fin si\r\n\t\t\t\tfin si\r\n            \tauxActor = nuevo Actor(nombreActor, apellidoActor)\r\n                si (opcion = 1) entonces\r\n                \tsi (!auxActor.getNombre().contiene(\"�\")) entonces\r\n                    \tsi(auxActor.getName().charEn(0) > 'A' && \t\t\t\t\t\t\t\t\t\t\t\tauxActor.getName().charEn(0) < 'Z') entonces\r\n                        \tauxActor.obtenerListaPeliculas().añadirPelicula(auxFilm)\r\n                            CatalogoActores.getMiCatalogoActores().añadirActor(auxActor)\r\n                            si (!auxFilm.getName().contiene(\"�\")) entonces\r\n                            \tCatalogoPelis.getMiCatalogoPelis().getPelicula(auxFilm.g\t\t\t\t\t\t\tetName()).getListaActores().añadirActor(auxActor)\r\n                            fin si\r\n                       fin si\r\n                   fin si\r\n\t\t\t\tsi no\r\n\t\t\t\t\tauxActor.getListaPeliculas().añadirPelicula(auxFilm)\r\n                \tCatalogoActores.getMiCatalogoActores().addActor(auxActor)\r\n                \tCatalogoPelis.getMiCatalogoPelis().getPelicula(auxFilm.getNombre()).\t\t\t\tgetListaActores().addActor(auxActor)\r\n               fin si\r\n               i++\r\n        \tfin mientras\r\n        \tsi (j==0) entonces\r\n        \t\tSystem.out.println(\"\\t[*] 0% file readed\")\r\n\t\t\tfin si\r\n        \tsi (((j*100)/contLineas) % 5 == 0) entonces\r\n        \t\tsi(((j*100)/contLineas) != auxCont) entonces\r\n            \t\tauxCont = ((j*100)(contLineas))\r\n                \tLong stopTime = System.currentTimeMilis()\r\n                \ttotal = (int) (stopTime - startTime) / 1000\r\n                \tSystem.out.println(\"\\t[*] \" + auxCont + \"% file readed. Time elapsed\t\t\t\t: \" + total + \"s\")\r\n            \tfin si\r\n        \tsi no, si (((j*100)/contLineas) % 5 == 0) entonces\r\n       \t \tJMenu.getMiJMenu().actualizarBarra((j * 100) / contLineas)\r\n\t\t\tfin si\r\n\t\tfin mientras\r\n\r\n####4.1.5 Método final\r\n\r\n```java\r\npublic void readFile(int pOption) throws IOException {\r\n\r\n        String[] auxLine1;\r\n\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        int j = 0; //j= counts the actual line of file\r\n        int total = 0; //total = saves total running time of reading\r\n        int auxCont = 0;  //auxCount = saves the percentage of reading of file\r\n\r\n        try (InputStream resource = FileManager.class.getResourceAsStream(\"testAllActors.txt\")) {\r\n\r\n            int contLines = countLines(new File(\"/Users/Josu/IdeaProjects/EDA16-17/src/lab1/testAllActors.txt\"));\r\n\r\n            String filmName, actorName, actorSurname;\r\n\r\n            String[] auxLine2;\r\n\r\n            Film auxFilm;\r\n\r\n            List<String> lines = new BufferedReader(new InputStreamReader(resource, StandardCharsets.UTF_8)).lines().collect(Collectors.toList());\r\n\r\n            for (String line : lines) {\r\n\r\n                auxLine1 = line.split(\"\\\\s+\\\\--->+\\\\s\"); //we split to get the name of the movie\r\n\r\n                if (pOption == 1) {\r\n                    NormalizeStrings.getMyNormalizeString().run(auxLine1);\r\n                }\r\n\r\n                filmName = auxLine1[0]; //here we save the name of the film\r\n\r\n                auxLine2 = auxLine1[1].split(\"\\\\s+\\\\&&&+\\\\s\"); //we split the array of actors in\r\n\r\n                auxFilm = new Film(filmName); //create a new film\r\n\r\n                if (pOption == 1) {\r\n                    if (!auxFilm.getName().contains(\"�\")) {\r\n                        FilmCatalog.getMyFilmCatalog().addFilm(auxFilm); //we add the film if its not been added before\r\n                    }\r\n                } else {\r\n                    FilmCatalog.getMyFilmCatalog().addFilm(auxFilm); //we add the film if its not been added before\r\n                }\r\n\r\n                int i = 0;\r\n\r\n                while (auxLine2.length > i) { // mientras el indice no sea mayor que el tamaño de la lista(indexOutOfBoundException)\r\n\r\n                    actorSurname = \"\";\r\n                    actorName = auxLine2[i];\r\n\r\n                    if (actorName.contains(\"(\")) {\r\n                        auxLine1 = actorName.split(\"\\\\s\\\\(\");\r\n                        actorName = auxLine1[0];\r\n                    }\r\n                    if (actorName.contains(\",\")) {//convertimos -> Apellido, Nombre --> Nombre, Apellido (como es habitual)\r\n                        auxLine1 = actorName.split(\",\\\\s*\");\r\n                        if (auxLine1.length > 1) {\r\n                            if (auxLine1[1].compareToIgnoreCase(\"null\") != 0) {\r\n                                actorSurname = auxLine1[0];\r\n                                actorName = auxLine1[1];\r\n                            } else {\r\n                                actorName = auxLine1[0];\r\n                            }\r\n                        }\r\n                    }\r\n                    Actor auxActor = new Actor(actorName, actorSurname);//Creamos la pelicula enviandole el nombre una vez normalizado\r\n\r\n                    if (pOption == 1) {\r\n                        if (!auxActor.getName().contains(\"�\")) {\r\n                            if (auxActor.getName().charAt(0) > 'A' && auxActor.getName().charAt(0) < 'Z') {\r\n                                auxActor.getFilmList().addFilm(auxFilm);\r\n                                ActorCatalog.getmyActorCatalog().addActor(auxActor);\r\n                                if (!auxFilm.getName().contains(\"�\")) {\r\n                                    FilmCatalog.getMyFilmCatalog().getFilm(auxFilm.getName()).getActorList().addActor(auxActor);\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        auxActor.getFilmList().addFilm(auxFilm);\r\n                        ActorCatalog.getmyActorCatalog().addActor(auxActor);\r\n                        FilmCatalog.getMyFilmCatalog().getFilm(auxFilm.getName()).getActorList().addActor(auxActor);\r\n                    }\r\n\r\n                    i++;\r\n\r\n                }\r\n                if (j == 0) {\r\n                    System.out.println(\"\\t[*] 0% file readed\");\r\n                }\r\n                j++;\r\n\r\n                if (((j * 100) / contLines) % 5 == 0) {\r\n                    if (((j * 100) / contLines) != auxCont) {\r\n                        auxCont = ((j * 100) / contLines);\r\n                        long stopTime = System.currentTimeMillis();\r\n                        total = (int) (stopTime - startTime) / 1000;\r\n\r\n                        System.out.println(\"\\t[*] \" + auxCont + \"% file readed. Time elapsed: \" + total + \"s\");\r\n                    }\r\n                } else if (((j * 100) / contLines) % 5 == 0) {\r\n                    SwingGUI.getMyJMenu().updateBar((j * 100) / contLines);\r\n                }\r\n            }\r\n        }\r\n        System.out.println(\"\\t-------- File read finished --------\\n\");\r\n        System.out.println(\"\\t--- Elapsed time to read the file ---> \" + total + \"s---\");\r\n        System.out.println(\"\\t--- Total actor/actresses found :\" + ActorCatalog.getmyActorCatalog().getActorL().size());\r\n        System.out.println(\"\\t--- Total films found : \" + FilmCatalog.getMyFilmCatalog().getSize());\r\n    }\r\n\r\n```\r\n### 4.2 buscarActor(String nombreActor)\r\n#### 4.2.1 Precondición/Postcondición\r\n- ++Pre:++ La lista no esta ordenada. No se repiten elementos.\r\n- ++Post:++ Obtenemos un actor de la lista en caso de existir, en caso contario obtendremos null.\r\n\r\n#### 4.2.2 Casos de prueba\r\n- El elemento no está en la lista\r\n- El elemento está en la lista\r\n\t- Es el primero de la lista\r\n\t- Está en una posición aleatoria (middle) o Es el último de la lista\r\n\r\n#### 4.2.3 Coste\r\n\r\nTenemos los actores guardados en una estructura de datos de tipo ***HashMap < String, Actor >* **, no es necesario hacer una 'busqueda' en si misma. Se reduce a acceder a un dato desde una clave.\r\nEl coste del algoritmo por lo tanto, es ***O(1)* **.\r\n\r\n#### 4.2.4 Pseudo-algoritmo\r\n\r\n```\r\nclase publica buscarActor (String nombreActor)\r\n\tsi (listaActores.obtener(nombreActor) es distinto de null entonces\r\n    \tdevuelve listaActores.obtener(nombreActor)\r\n    si no\r\n    \tdevuelve null\r\n\r\n```\r\n\r\n#### 4.2.5 Metodo final (código)\r\n\r\n```java\r\npublic Actor searchActor(Actor pActor) {\r\n        if (this.exist(pActor.getName(), pActor.getSurname())) {\r\n            return this.actorL.get(pActor.getName() + \" \" + pActor.getSurname());\r\n        }\r\n        return null;\r\n}\r\n\r\n```\r\n\r\nEste método, utiliza otro método definido previamente:\r\n\r\n```java\r\nprivate boolean exist(String pActorName, String pActorSurname) {\r\n\treturn actorL.get(pActorName + \" \" + pActorSurname) != null;\r\n}\r\n\r\n```\r\n\r\n* * *\r\n###4.3 addActor()\r\n\r\n\r\n####4.3.1 Precondicion/Postcondicion\r\n- ++Precondicion:++ Tendremos un actor.\r\n- ++Postcondicion:++ El programa habra añadido el actor a la lista.\r\n\r\n####4.3.2 Casos de prueba\r\n* Actor null\r\n* Actor existente ya en la lista\r\n* Nombre vacio\r\n\r\n####4.3.3 Coste\r\nEste método recibirá un objeto pActor, y lo que tendrá que hacer es comprobar si ese actor ya existe en el catálogo, y para ello, al estar usando estructuras HashMap, el coste que tendrá será constante; por consiguiente el coste del método completo de añadirActor() será lineal ya que la otra llamada de la que hacemos uso es put() que no aumentara apenas el coste.\r\n\r\n####4.3.4 Pseudo-algoritmo\r\n\r\n\tsi (!this.existe(pActor.getNombre(), pActor.getApellido)) entonces\r\n    \tthis.listaActores.poner(pActor.getNombre() + \" \"+pActor.getApellido(), pActor)\r\n    fin si\r\n\r\n\r\n####4.3.5 Método final\r\n\r\n```java\r\n public void addActor(Actor pActor) {\r\n        if (!this.exist(pActor.getName(), pActor.getSurname())) {\r\n            this.actorL.put(pActor.getName() + \" \" + pActor.getSurname(), pActor);\r\n        }\r\n }\r\n\r\n```\r\n\r\n##4.5 sortImpl()\r\n\r\n###4.5.1 Precondicion/PostCondicion\r\n- ++Precondición++: El programa recibe un array de Strings que tendrá los nombres de los actores, y dos números que nos servirán de índices.\r\n- ++Postcondición++: Tras ejecutar el programa nuestro cátalogo de actores estará ordenado alfabeticamente.\r\n\r\n###4.5.2 Casos de prueba\r\n* Lista vacía\r\n* Lista no vacía.\r\n\r\n###4.5.3 Coste\r\n\r\nEn el mejor caso, el pivote termina en el centro de la lista, dividiéndola en dos sublistas de igual tamaño. En este caso, el orden de complejidad del algoritmo es ***O(n·log n)* **.\r\nEn el peor caso, el pivote termina en un extremo de la lista. El orden de complejidad del algoritmo es entonces de ***O(n²)* **. El peor caso dependerá de la implementación del algoritmo, aunque habitualmente ocurre en listas que se encuentran ordenadas, o casi ordenadas.\r\nEn el caso promedio, el orden es ***O(n·log n)* **.\r\n\r\n###4.5.4 Pseudo-algoritmo\r\n\r\n\t private static void sortImpl(String[] array, int pivoteInicio, int pivoteFinal, int tamañoString) throws NullPointerException {\r\n\r\n\r\n\t\tint rango = pivoteFinal - pivoteInicio\r\n        \r\n\t\tsi (rango < 2) entonces\r\n        \treturn;\r\n        fin si\r\n\r\n\t\tint selec = pivoteInicio\r\n\r\n        mientras(int index = pivoteInicio; index < pivoteFinal; ++index)\r\n        \tString actual = array(index)\r\n            si(actual.length() == stringLength) entonces\r\n            \tString temp = array[selec]\r\n                array[selec] = actual\r\n                array[index] = tmp\r\n                ++finger\r\n            fin si\r\n       fin mientras\r\n       \r\n\t\tpivoteInicio = selec\r\n       \r\n        String izq = array[pivoteInicio];\r\n        String dcha = array[pivoteFinal - 1];\r\n        String medio = array[pivoteInicio + rango >> 1];\r\n\r\n        String pivote = medio(izq, medio, dhca);\r\n        \r\n\t\tmientras (int index = pivoteInicio; index < pivoteFinal; ++index)\r\n        \tString actual = array[index]\r\n            \r\n            si(actual.charEn(tamañoString) < pivote.charEn(tamañoString)) entonces\r\n            \tString tmp=array[selec]\r\n                array[selec] = actual\r\n                array[index] = tmp\r\n\t\t\t\t++finger\r\n            fin si\r\n        fin mientras\r\n        \r\n        sortImpl(array, pivoteInicio, selec, tamañoString)\r\n\r\n        pivoteInicio = selec\r\n\r\n        mientras (int index = pivoteInicio; index < pivoteFinal; ++index)\r\n        \tString actual = array[index]\r\n\t\t\t\r\n            si (actual.charEn(tamañoString) == pivote.charEn(tamañoString)) entonces\r\n            \tString tmp = array[selec]\r\n                array[selec] = actual\r\n                array[index] = tmp\r\n                ++finger\r\n            fin si\r\n        fin mientras    \r\n          \r\n\t\tsortImp(array, pivoteInicio, selec, tamañoString + 1)\r\n        sortImpl(array, selec, pivoteFinal, tamañoString)\r\n   \t}\r\n    \r\n    \r\n###4.5.5 Método final\r\n\r\n```java\r\nprivate static void sortImpl(String[] array, int fromIndex, int toIndex, int stringLength) throws NullPointerException {\r\n\r\n\r\n\r\n        int rangeLength = toIndex - fromIndex;\r\n\r\n        if (rangeLength < 2) {\r\n            return;\r\n        }\r\n\r\n        int finger = fromIndex;\r\n\r\n        // Put all strings of length 'stringLength' to the beginning of the\r\n        // requested sort range.\r\n        for (int index = fromIndex; index < toIndex; ++index) {\r\n            String current = array[index];\r\n            if (current.length() == stringLength) {\r\n                String tmp = array[finger];\r\n                array[finger] = current;\r\n                array[index] = tmp;\r\n                ++finger;\r\n            }\r\n        }\r\n\r\n        fromIndex = finger;\r\n\r\n        // Choose a pivot string by median.\r\n        String probeLeft = array[fromIndex];\r\n        String probeRight = array[toIndex - 1];\r\n        String probeMiddle = array[fromIndex + rangeLength >> 1];\r\n\r\n        String pivot = median(probeLeft, probeMiddle, probeRight);\r\n\r\n        // Process strings S for which S[stringLength] < X[stringLength].\r\n        for (int index = fromIndex; index < toIndex; ++index) {\r\n            String current = array[index];\r\n\r\n            if (current.charAt(stringLength) < pivot.charAt(stringLength)) {\r\n                String tmp = array[finger];\r\n                array[finger] = current;\r\n                array[index] = tmp;\r\n                ++finger;\r\n            }\r\n        }\r\n\r\n        sortImpl(array, fromIndex, finger, stringLength);\r\n\r\n        fromIndex = finger;\r\n\r\n        for (int index = fromIndex; index < toIndex; ++index) {\r\n            String current = array[index];\r\n\r\n            if (current.charAt(stringLength) == pivot.charAt(stringLength)) {\r\n                String tmp = array[finger];\r\n                array[finger] = current;\r\n                array[index] = tmp;\r\n                ++finger;\r\n            }\r\n        }\r\n\r\n        sortImpl(array, fromIndex, finger, stringLength + 1);\r\n        sortImpl(array, finger, toIndex, stringLength);\r\n    }\r\n\r\n```\r\n\r\n## 5. Código completo\r\n\r\n- Se incluye el **diagrama de clases** completo en formato `.png`\r\n- **Los ficheros `.java`** que contienen todos los métodos\r\n- **Los ficheros resultado** de la carga del fichero original\r\n\t- Fichero resultado con los actores y peliculas con nombres normalizados (y descartando aquellos que tras el proceso seguian estando mal escritos)\r\n\t- Fichero resultado con todos los actores y peliculas que nuestro programa trata en la carga\r\n\r\n### 5.1 Actor\r\n```java\r\npublic class Actor {\r\n\r\n    private String name;\r\n    private String surname;\r\n    private FilmList filmL;\r\n\r\n    public Actor(String pName, String pSurname) {\r\n        this.name = pName;\r\n        this.surname = pSurname;\r\n        this.filmL = new FilmList();\r\n    }\r\n\r\n    public FilmList getFilmList() {\r\n        return this.filmL;\r\n    }\r\n\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    public String getSurname() {\r\n        return this.surname;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 5.2 ActorCatalog\r\n```java\r\npublic class ActorCatalog {\r\n\r\n    private static ActorCatalog myActorCatalog;\r\n    private HashMap<String, Actor> actorL;\r\n\r\n    private ActorCatalog() {\r\n        this.actorL = new HashMap<>();\r\n    }\r\n\r\n    public static ActorCatalog getmyActorCatalog() {\r\n        if (myActorCatalog == null) {\r\n            myActorCatalog = new ActorCatalog();\r\n        }\r\n        return myActorCatalog;\r\n    }\r\n\r\n    public HashMap<String, Actor> getActorL() {\r\n        return this.actorL;\r\n    }\r\n\r\n    private boolean exist(String pActorName, String pActorSurname) {\r\n        return actorL.get(pActorName + \" \" + pActorSurname) != null;\r\n    }\r\n\r\n    public void addActor(Actor pActor) {\r\n        if (!this.exist(pActor.getName(), pActor.getSurname())) {\r\n            this.actorL.put(pActor.getName() + \" \" + pActor.getSurname(), pActor);\r\n        }\r\n    }\r\n\r\n    public Actor searchActor(Actor pActor) {\r\n        if (this.exist(pActor.getName(), pActor.getSurname())) {\r\n            return this.actorL.get(pActor.getName() + \" \" + pActor.getSurname());\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public void removeActor(Actor pActor) {\r\n        if (this.exist(pActor.getName(), pActor.getSurname())) {\r\n            this.actorL.remove(pActor.getName() + \" \" + pActor.getSurname());\r\n            System.out.println(\"Actor erased\");\r\n        } else {\r\n            System.out.println(\"Actor not found\");\r\n        }\r\n    }\r\n\r\n    public String[] quickSortList() {\r\n        String[] auxS = new String[actorL.size()];\r\n        int i = 0;\r\n        for (String key : actorL.keySet()) {\r\n            auxS[i] = key;\r\n            i++;\r\n        }\r\n        StringQuickSort.sort(auxS);\r\n        return auxS;\r\n    }\r\n\r\n    public void printList(String[] auxS) {\r\n        for (String key : auxS) {\r\n            System.out.println(key);\r\n        }\r\n    }\r\n}\r\n```\r\n### 5.3 ActorList\r\n```java\r\npublic class ActorList {\r\n\r\n    private HashMap<String, Actor> actorList;\r\n\r\n\r\n    public ActorList() {\r\n        this.actorList = new HashMap<>();\r\n    }\r\n\r\n\r\n    public boolean exist(String pActorName, String pActorSurname) {\r\n        return this.actorList.get(pActorName + \" \" + pActorSurname) != null;\r\n    }\r\n\r\n    public void addActor(Actor auxActor) {\r\n        if (!this.exist(auxActor.getName(), auxActor.getSurname())) {\r\n            this.actorList.put(auxActor.getName() + \" \" + auxActor.getSurname(), auxActor);\r\n        }\r\n    }\r\n\r\n    public Actor getActor(String pActorName, String pActorSurname) {\r\n        if (this.actorList.get(pActorName + \" \" + pActorSurname) != null) {\r\n            return actorList.get(pActorName);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public void removeActor(Actor pActor) {\r\n        if (this.actorList.get(pActor.getName() + \" \" + pActor.getSurname()) != null) {\r\n            this.actorList.remove(pActor.getName() + \" \" + pActor.getSurname());\r\n        }\r\n    }\r\n\r\n    public void printActors() {\r\n        System.out.println(\"These are all the actors: \");\r\n        for (HashMap.Entry<String, Actor> entry : actorList.entrySet()) {\r\n            String key = entry.getKey();\r\n            System.out.println(key.toString());\r\n        }\r\n    }\r\n}\r\n```\r\n### 5.4 EDA1617\r\n```java\r\npublic class EDA1516 {\r\n\r\n    /**\r\n     * @param args the command line arguments\r\n     */\r\n    public static void main(String[] args) throws FileNotFoundException {\r\n\r\n        Object[] options = {\"GUI based\", \"Console based\"};\r\n\r\n        //int n = JOptionPane.showOptionDialog(null,\"Choose what launcher do you want to use\", \"EDA16-17 Selection Menu\",JOptionPane.YES_NO_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[1])\r\n\r\n        System.out.println(\"\\t\\t***** Welcome to EDA16/17 project *****\\n\");\r\n\r\n        System.out.println(\"\\tSelect (1) for gui based program launch (still in development, less customizable)\");\r\n        System.out.println(\"\\tSelect (2) for terminal based program launch (finished and more customizable experience\");\r\n\r\n        int n = Keyboard.getMyKeyboard().getInt();\r\n\r\n        if (n == 1) {\r\n\r\n            JFrame frame = SwingGUI.getMyJMenu();\r\n\r\n            Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();         //En dim guardamos el tamaño de la pantalla donde se esta ejecutando el programa\r\n\r\n            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //fijamos que la operacion por defecto al cerrar es salir\r\n            frame.pack();\r\n            frame.isAlwaysOnTop();\r\n            frame.setLocation(dim.width / 2 - frame.getSize().width / 2, dim.height / 2 - frame.getSize().height / 2);         //Fijamos por defecto que la ventana siempre aparezca en el centro\r\n            frame.setVisible(true); //hacemos el frame visible\r\n            frame.setResizable(false);\r\n        } else {\r\n            TerminalUI.main();\r\n        }\r\n    }\r\n}\r\n```\r\n### 5.5 FileManager\r\n```java\r\npublic class FileManager {\r\n\r\n    private static FileManager myFileManager;\r\n\r\n    private FileManager() {\r\n\r\n    }\r\n\r\n    public static FileManager getMyFileManager() {\r\n        if (myFileManager == null) {\r\n            myFileManager = new FileManager();\r\n        }\r\n        return myFileManager;\r\n    }\r\n\r\n    public static int countLines(File pFile) throws IOException {\r\n        LineNumberReader lnr = new LineNumberReader(new FileReader(pFile));\r\n        lnr.skip(Long.MAX_VALUE);\r\n        lnr.close();\r\n        return lnr.getLineNumber() + 1;//Add 1 because line index starts at 0\r\n    }\r\n\r\n    public void readFile(int pOption) throws IOException {\r\n\r\n        String[] auxLine1;\r\n\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        int j = 0; //j= counts the actual line of file\r\n        int total = 0; //total = saves total running time of reading\r\n        int auxCont = 0;  //auxCount = saves the percentage of reading of file\r\n\r\n        try (InputStream resource = FileManager.class.getResourceAsStream(\"testAllActors.txt\")) {\r\n\r\n            int contLines = countLines(new File(\"/Users/Josu/IdeaProjects/EDA16-17/src/lab1/testAllActors.txt\"));\r\n\r\n            String filmName, actorName, actorSurname;\r\n\r\n            String[] auxLine2;\r\n\r\n            Film auxFilm;\r\n\r\n            List<String> lines = new BufferedReader(new InputStreamReader(resource, StandardCharsets.UTF_8)).lines().collect(Collectors.toList());\r\n\r\n            for (String line : lines) {\r\n\r\n                auxLine1 = line.split(\"\\\\s+\\\\--->+\\\\s\"); //we split to get the name of the movie\r\n\r\n                if (pOption == 1) {\r\n                    NormalizeStrings.getMyNormalizeString().run(auxLine1);\r\n                }\r\n\r\n                filmName = auxLine1[0]; //here we save the name of the film\r\n\r\n                auxLine2 = auxLine1[1].split(\"\\\\s+\\\\&&&+\\\\s\"); //we split the array of actors in\r\n\r\n                auxFilm = new Film(filmName); //create a new film\r\n\r\n                if (pOption == 1) {\r\n                    if (!auxFilm.getName().contains(\"�\")) {\r\n                        FilmCatalog.getMyFilmCatalog().addFilm(auxFilm); //we add the film if its not been added before\r\n                    }\r\n                } else {\r\n                    FilmCatalog.getMyFilmCatalog().addFilm(auxFilm); //we add the film if its not been added before\r\n                }\r\n\r\n                int i = 0;\r\n\r\n                while (auxLine2.length > i) { // mientras el indice no sea mayor que el tamaño de la lista(indexOutOfBoundException)\r\n\r\n                    actorSurname = \"\";\r\n                    actorName = auxLine2[i];\r\n\r\n                    if (actorName.contains(\"(\")) {\r\n                        auxLine1 = actorName.split(\"\\\\s\\\\(\");\r\n                        actorName = auxLine1[0];\r\n                    }\r\n                    if (actorName.contains(\",\")) {//convertimos -> Apellido, Nombre --> Nombre, Apellido (como es habitual)\r\n                        auxLine1 = actorName.split(\",\\\\s*\");\r\n                        if (auxLine1.length > 1) {\r\n                            if (auxLine1[1].compareToIgnoreCase(\"null\") != 0) {\r\n                                actorSurname = auxLine1[0];\r\n                                actorName = auxLine1[1];\r\n                            } else {\r\n                                actorName = auxLine1[0];\r\n                            }\r\n                        }\r\n                    }\r\n                    Actor auxActor = new Actor(actorName, actorSurname);//Creamos la pelicula enviandole el nombre una vez normalizado\r\n\r\n                    if (pOption == 1) {\r\n                        if (!auxActor.getName().contains(\"�\")) {\r\n                            if (auxActor.getName().charAt(0) > 'A' && auxActor.getName().charAt(0) < 'Z') {\r\n                                auxActor.getFilmList().addFilm(auxFilm);\r\n                                ActorCatalog.getmyActorCatalog().addActor(auxActor);\r\n                                if (!auxFilm.getName().contains(\"�\")) {\r\n                                    FilmCatalog.getMyFilmCatalog().getFilm(auxFilm.getName()).getActorList().addActor(auxActor);\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        auxActor.getFilmList().addFilm(auxFilm);\r\n                        ActorCatalog.getmyActorCatalog().addActor(auxActor);\r\n                        FilmCatalog.getMyFilmCatalog().getFilm(auxFilm.getName()).getActorList().addActor(auxActor);\r\n                    }\r\n\r\n                    i++;\r\n\r\n                }\r\n                if (j == 0) {\r\n                    System.out.println(\"\\t[*] 0% file readed\");\r\n                }\r\n                j++;\r\n\r\n                if (((j * 100) / contLines) % 5 == 0) {\r\n                    if (((j * 100) / contLines) != auxCont) {\r\n                        auxCont = ((j * 100) / contLines);\r\n                        long stopTime = System.currentTimeMillis();\r\n                        total = (int) (stopTime - startTime) / 1000;\r\n\r\n                        System.out.println(\"\\t[*] \" + auxCont + \"% file readed. Time elapsed: \" + total + \"s\");\r\n                    }\r\n                } else if (((j * 100) / contLines) % 5 == 0) {\r\n                    SwingGUI.getMyJMenu().updateBar((j * 100) / contLines);\r\n                }\r\n            }\r\n        }\r\n        System.out.println(\"\\t-------- File read finished --------\\n\");\r\n        System.out.println(\"\\t--- Elapsed time to read the file ---> \" + total + \"s---\");\r\n        System.out.println(\"\\t--- Total actor/actresses found :\" + ActorCatalog.getmyActorCatalog().getActorL().size());\r\n        System.out.println(\"\\t--- Total films found : \" + FilmCatalog.getMyFilmCatalog().getSize());\r\n    }\r\n\r\n    @SuppressWarnings(\"rawtypes\")\r\n    public void exportToFile() {\r\n\r\n        String[] keys = ActorCatalog.getmyActorCatalog().quickSortList();\r\n\r\n        FileWriter fichero = null;\r\n        PrintWriter pw;\r\n\r\n        long timeStart = System.currentTimeMillis();\r\n\r\n        try {\r\n            String directorio = System.getProperty(\"user.dir\");//cogemos variable entorno\r\n            fichero = new FileWriter(directorio + \"/ActorList_ordered.txt\");\r\n            pw = new PrintWriter(fichero);\r\n\r\n            int i = 1;\r\n            for (int i1 = 0, keysLength = keys.length; i1 < keysLength; i1++) {\r\n                Object key = keys[i1];\r\n                pw.print(\"Actor \" + i + \" -> \");\r\n                pw.println(ActorCatalog.getmyActorCatalog().getActorL().get(key).getName() + \" \" + ActorCatalog.getmyActorCatalog().getActorL().get(key).getSurname());\r\n                Object[] keys2;\r\n                keys2 = ActorCatalog.getmyActorCatalog().getActorL().get(key).getFilmList().getFilmL().keySet().toArray();\r\n                for (Object auxKey : keys2) {\r\n                    pw.println(\"\\t\" + ActorCatalog.getmyActorCatalog().getActorL().get(key).getFilmList().getFilmL().get(auxKey).getName());\r\n                }\r\n                i++;\r\n                int percentage = (i * 100) / ActorCatalog.getmyActorCatalog().getActorL().size();\r\n                if (((i * 100) / ActorCatalog.getmyActorCatalog().getActorL().size()) % 5 == 0) {\r\n                    if (((i * 100) / ActorCatalog.getmyActorCatalog().getActorL().size()) != percentage) {\r\n                        System.out.println(\"\\t\\t[*] \" + percentage + \"%\");\r\n                    }\r\n                }\r\n\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                if (null != fichero) {\r\n                    fichero.close();\r\n                }\r\n                long timeTotal = (System.currentTimeMillis() - timeStart);\r\n                System.out.println(\"\\t\\t --- Elapsed time to export the file --- : \" + (int) timeTotal / 1000 + \"sec, \" + timeTotal * 1000 + \"ms\\n\");\r\n                System.out.println(\"\\n\\tFile exported to: \" + System.getProperty(\"user.dir\"));\r\n            } catch (Exception e2) {\r\n                e2.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n### 5.6 Film\r\n```java\r\npublic class Film {\r\n    private String name;\r\n    private int earned = 0;\r\n    private ActorList actorList;\r\n\r\n    public Film(String pName) {\r\n        this.name = pName;\r\n        this.actorList = new ActorList();\r\n    }\r\n\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    public int getEarned() {\r\n        return this.earned;\r\n    }\r\n\r\n    public void incrementEarned(int auxEarned) {\r\n        this.earned += auxEarned;\r\n    }\r\n\r\n    public ActorList getActorList() {\r\n        return this.actorList;\r\n    }\r\n}\r\n```\r\n### 5.7 FilmCatalog\r\n```java\r\npublic class FilmCatalog {\r\n\r\n    private static FilmCatalog myFilmCatalog;\r\n    private HashMap<String, Film> filmL;\r\n\r\n    private FilmCatalog() {\r\n        this.filmL = new HashMap<>();\r\n    }\r\n\r\n    public static FilmCatalog getMyFilmCatalog() {\r\n        if (myFilmCatalog == null) {\r\n            myFilmCatalog = new FilmCatalog();\r\n        }\r\n        return myFilmCatalog;\r\n    }\r\n\r\n    public boolean exist(String pFilmName) {\r\n        return filmL.get(pFilmName) != null;\r\n    }\r\n\r\n    public void addFilm(Film pFilm) {\r\n        if (!this.exist(pFilm.getName())) {\r\n            this.filmL.put(pFilm.getName(), pFilm);\r\n        }\r\n    }\r\n\r\n    public Film getFilm(String pFilmName) {\r\n        if (this.exist(pFilmName)) {\r\n            return this.filmL.get(pFilmName);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public int getSize(){\r\n        return this.filmL.size();\r\n    }\r\n}\r\n```\r\n### 5.8 FilmList\r\n```java\r\npublic class FilmList {\r\n\r\n    private HashMap<String, Film> filmL;\r\n\r\n    public FilmList() {\r\n        this.filmL = new HashMap<>();\r\n    }\r\n\r\n\r\n    private boolean exist(String pFilmName) {\r\n        return this.filmL.get(pFilmName) != null;\r\n    }\r\n\r\n    public void addFilm(Film pFilm) {\r\n        if (!this.exist(pFilm.getName())) {\r\n            this.filmL.put(pFilm.getName(), pFilm);\r\n        }\r\n    }\r\n\r\n    public Film getFilm(String pFilmName) {\r\n        if (this.filmL.get(pFilmName) != null) {\r\n            return this.filmL.get(pFilmName);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public HashMap<String, Film> getFilmL() {\r\n        return this.filmL;\r\n    }\r\n\r\n    public void printFilms() {\r\n        System.out.println(\"These are all the films: \");\r\n        for (HashMap.Entry<String, Film> entry : filmL.entrySet()) {\r\n            String key = entry.getKey();\r\n            System.out.println(key.toString());\r\n        }\r\n    }\r\n}\r\n```\r\n### 5.9 Keyboard\r\n```java\r\npublic class Keyboard {\r\n\r\n\tprivate static Keyboard miKeyboard;\r\n\tprivate Scanner scan;\r\n\t\r\n\tpublic Keyboard(){\r\n\t\tscan = new Scanner(System.in);\r\n\t}\r\n\t\r\n\tpublic static Keyboard getMyKeyboard(){\r\n\t\tif (miKeyboard==null){\r\n\t\t\tmiKeyboard = new Keyboard();\r\n\t\t}\r\n\t\treturn miKeyboard;\r\n\t}\r\n\r\n\tpublic int getInt(){\r\n\t\tString auxS = scan.nextLine();\r\n\t\twhile(!this.isNumeric(auxS)){\r\n\t\t\ttry{\r\n\t\t\t\tInteger.parseInt(auxS);\r\n\t\t\t}\r\n\t\t\tcatch (NumberFormatException nfe){\r\n\t\t\t\tSystem.out.println(\"Insert a valid number\");\r\n\t\t\t\tauxS = scan.nextLine();\r\n\t\t\t}\r\n\t\t}\r\n\t\tint resul = Integer.parseInt(auxS);\r\n\t\treturn resul;\r\n\t}\r\n    \r\n\tprivate boolean isNumeric(String cadena){\r\n\t\ttry{\r\n\t\t\tInteger.parseInt(cadena);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tcatch(NumberFormatException nfe){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic String getString(){\r\n\t\tString auxS = scan.nextLine();\r\n\t\treturn auxS;\r\n\t}\r\n}\r\n```\r\n### 5.10 NormalizeStrings\r\n```java\r\npublic class NormalizeStrings extends Thread {\r\n\r\n    private static NormalizeStrings myNormalizeString;\r\n\r\n    public static NormalizeStrings getMyNormalizeString() {\r\n        if (myNormalizeString == null) {\r\n            myNormalizeString = new NormalizeStrings();\r\n        }\r\n        return myNormalizeString;\r\n    }\r\n\r\n    public void run(String[] pLine) {\r\n\r\n        for (int i = 0; i < pLine.length; i++) {\r\n            if (pLine[i].contains(\"Ã¡\")) {\r\n                pLine[i].replaceAll(\"Ã¡\", \"a\");\r\n            } else if (pLine[i].contains(\"Ã©\")) {\r\n                pLine[i].replaceAll(\"Ã©\", \"e\");\r\n            } else if (pLine[i].contains(\"Ã­\")) {\r\n                pLine[i].replaceAll(\"Ã­\", \"i\");\r\n            } else if (pLine[i].contains(\"Ã³\")) {\r\n                pLine[i].replaceAll(\"Ã³\", \"o\");\r\n            } else if (pLine[i].contains(\"Ãº\")) {\r\n                pLine[i].replaceAll(\"Ãº\", \"u\");\r\n            } else if (pLine[i].contains(\"Ã�\")) {\r\n                pLine[i].replaceAll(\"Ã�\", \"A\");\r\n            } else if (pLine[i].contains(\"Ã‰\")) {\r\n                pLine[i].replaceAll(\"Ã‰\", \"E\");\r\n            } else if (pLine[i].contains(\"Ã�\")) {\r\n                pLine[i].replaceAll(\"Ã�\", \"I\");\r\n            } else if (pLine[i].contains(\"Ã“\")) {\r\n                pLine[i].replaceAll(\"Ã“\", \"O\");\r\n            } else if (pLine[i].contains(\"Ãš\")) {\r\n                pLine[i].replaceAll(\"Ãš\", \"U\");\r\n            } else if (pLine[i].contains(\"Ã§\")) {\r\n                pLine[i].replaceAll(\"Ã§\", \"c\");\r\n            } else if (pLine[i].contains(\"Ã\")) {\r\n                pLine[i].replaceAll(\"Ã\", \"a\");\r\n            } else if (pLine[i].contains(\"Ã¨\")) {\r\n                pLine[i].replaceAll(\"Ã¨\", \"e\");\r\n            } else if (pLine[i].contains(\"Ã¬\")) {\r\n                pLine[i].replaceAll(\"Ã¬\", \"i\");\r\n            } else if (pLine[i].contains(\"Ã²\")) {\r\n                pLine[i].replaceAll(\"Ã²\", \"o\");\r\n            } else if (pLine[i].contains(\"Ã¹\")) {\r\n                pLine[i].replaceAll(\"Ã¹\", \"u\");\r\n            } else if (pLine[i].contains(\"Ã€\")) {\r\n                pLine[i].replaceAll(\"Ã€\", \"A\");\r\n            } else if (pLine[i].contains(\"Ãˆ\")) {\r\n                pLine[i].replaceAll(\"Ãˆ\", \"E\");\r\n            } else if (pLine[i].contains(\"ÃŒ\")) {\r\n                pLine[i].replaceAll(\"ÃŒ\", \"I\");\r\n            } else if (pLine[i].contains(\"Ã’\")) {\r\n                pLine[i].replaceAll(\"Ã’\", \"O\");\r\n            } else if (pLine[i].contains(\"Ã™\")) {\r\n                pLine[i].replaceAll(\"Ã™\", \"U\");\r\n            } else if (pLine[i].contains(\"Ã‡\")) {\r\n                pLine[i].replaceAll(\"Ã‡\", \"C\");\r\n            } else if (pLine[i].contains(\"�\")) {\r\n                pLine[i].replaceAll(\"�\", \"A\");\r\n            } else if (pLine[i].contains(\"�s\")) {\r\n                pLine[i].replaceAll(\"�s\", \"Os\");\r\n            }\r\n            this.waitXseconds(0.1);\r\n        }\r\n    }\r\n\r\n    private void waitXseconds(double ms) {\r\n        try {\r\n            Thread.sleep((long)ms * 10);\r\n        } catch (InterruptedException ex) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n### 5.11 StringQuickSort\r\n```java\r\npublic class StringQuickSort {\r\n\r\n    public static void sort(String[] array) {\r\n        sort(array, 0, array.length);\r\n    }\r\n\r\n    private static void sort(String[] array, int fromIndex, int toIndex) {\r\n        if (toIndex - fromIndex < 2) {\r\n            return;\r\n        }\r\n        long timeStart = System.currentTimeMillis();\r\n        sortImpl(array, fromIndex, toIndex, 0);\r\n        long timeTotal = (System.currentTimeMillis() - timeStart);\r\n        System.out.println(\"\\t\\t --- Elapsed time to order the actor list --- : \" + (int) timeTotal / 1000 + \"sec, \" + timeTotal * 1000 + \"ms\\n\");\r\n    }\r\n\r\n    private static void sortImpl(String[] array, int fromIndex, int toIndex, int stringLength) throws NullPointerException {\r\n\r\n\r\n\r\n        int rangeLength = toIndex - fromIndex;\r\n\r\n        if (rangeLength < 2) {\r\n            return;\r\n        }\r\n\r\n        int finger = fromIndex;\r\n\r\n        // Put all strings of length 'stringLength' to the beginning of the\r\n        // requested sort range.\r\n        for (int index = fromIndex; index < toIndex; ++index) {\r\n            String current = array[index];\r\n            if (current.length() == stringLength) {\r\n                String tmp = array[finger];\r\n                array[finger] = current;\r\n                array[index] = tmp;\r\n                ++finger;\r\n            }\r\n        }\r\n\r\n        fromIndex = finger;\r\n\r\n        // Choose a pivot string by median.\r\n        String probeLeft = array[fromIndex];\r\n        String probeRight = array[toIndex - 1];\r\n        String probeMiddle = array[fromIndex + rangeLength >> 1];\r\n\r\n        String pivot = median(probeLeft, probeMiddle, probeRight);\r\n\r\n        // Process strings S for which S[stringLength] < X[stringLength].\r\n        for (int index = fromIndex; index < toIndex; ++index) {\r\n            String current = array[index];\r\n\r\n            if (current.charAt(stringLength) < pivot.charAt(stringLength)) {\r\n                String tmp = array[finger];\r\n                array[finger] = current;\r\n                array[index] = tmp;\r\n                ++finger;\r\n            }\r\n        }\r\n\r\n        sortImpl(array, fromIndex, finger, stringLength);\r\n\r\n        fromIndex = finger;\r\n\r\n        for (int index = fromIndex; index < toIndex; ++index) {\r\n            String current = array[index];\r\n\r\n            if (current.charAt(stringLength) == pivot.charAt(stringLength)) {\r\n                String tmp = array[finger];\r\n                array[finger] = current;\r\n                array[index] = tmp;\r\n                ++finger;\r\n            }\r\n        }\r\n\r\n        sortImpl(array, fromIndex, finger, stringLength + 1);\r\n        sortImpl(array, finger, toIndex, stringLength);\r\n    }\r\n\r\n    private static String median(String a, String b, String c) {\r\n        if (a.compareTo(b) <= 0) {\r\n            if (c.compareTo(a) <= 0) {\r\n                return a;\r\n            }\r\n            return b.compareTo(c) <= 0 ? b : c;\r\n        }\r\n\r\n        if (c.compareTo(b) <= 0) {\r\n            return b;\r\n        }\r\n        return a.compareTo(c) <= 0 ? a : c;\r\n    }\r\n\r\n}\r\n```\r\n### 5.12 SwingGUI\r\n```java\r\npublic class SwingGUI extends javax.swing.JFrame {\r\n\r\n    private static SwingGUI myJMenu;\r\n    private javax.swing.JButton button1;\r\n    private javax.swing.JButton button2;\r\n    private javax.swing.JTextField button2textField;\r\n    private javax.swing.JButton button3;\r\n    private javax.swing.JTextField button3textField;\r\n    private javax.swing.JButton button4;\r\n    private javax.swing.JTextField button4textField;\r\n    private javax.swing.JButton button5;\r\n    private javax.swing.JTextField button5textField;\r\n    private javax.swing.JButton button6;\r\n    private javax.swing.JTextField button6textField;\r\n    private javax.swing.JButton button7;\r\n    private javax.swing.JTextField button7textField;\r\n    private javax.swing.JButton button8;\r\n    private javax.swing.JButton button9;\r\n    private javax.swing.JLabel jLabel1;\r\n    private javax.swing.JLabel jLabel10;\r\n    private javax.swing.JLabel jLabel2;\r\n    private javax.swing.JLabel jLabel3;\r\n    private javax.swing.JLabel jLabel4;\r\n    private javax.swing.JLabel jLabel5;\r\n    private javax.swing.JLabel jLabel6;\r\n    private javax.swing.JLabel jLabel7;\r\n    private javax.swing.JLabel jLabel8;\r\n    private javax.swing.JLabel jLabel9;\r\n    private javax.swing.JProgressBar jProgressBar;\r\n\r\n    /**\r\n     * Creates new form SwingGUI\r\n     */\r\n    public SwingGUI() {\r\n        initComponents();\r\n    }\r\n\r\n    public static SwingGUI getMyJMenu() {\r\n        if (myJMenu == null) {\r\n            myJMenu = new SwingGUI();\r\n        }\r\n        return myJMenu;\r\n    }\r\n\r\n    /**\r\n     * This method is called from within the constructor to initialize the form.\r\n     * WARNING: Do NOT modify this code. The content of this method is always\r\n     * regenerated by the Form Editor.\r\n     */\r\n    private void initComponents() {\r\n\r\n        jLabel1 = new javax.swing.JLabel();\r\n        button1 = new javax.swing.JButton();\r\n        button2 = new javax.swing.JButton();\r\n        button3 = new javax.swing.JButton();\r\n        jLabel2 = new javax.swing.JLabel();\r\n        jLabel3 = new javax.swing.JLabel();\r\n        jLabel4 = new javax.swing.JLabel();\r\n        button4 = new javax.swing.JButton();\r\n        jLabel5 = new javax.swing.JLabel();\r\n        button5 = new javax.swing.JButton();\r\n        jLabel6 = new javax.swing.JLabel();\r\n        button6 = new javax.swing.JButton();\r\n        jLabel7 = new javax.swing.JLabel();\r\n        button7 = new javax.swing.JButton();\r\n        jLabel8 = new javax.swing.JLabel();\r\n        button8 = new javax.swing.JButton();\r\n        jLabel9 = new javax.swing.JLabel();\r\n        button9 = new javax.swing.JButton();\r\n        jLabel10 = new javax.swing.JLabel();\r\n        jProgressBar = new javax.swing.JProgressBar();\r\n        button2textField = new javax.swing.JTextField();\r\n        button3textField = new javax.swing.JTextField();\r\n        button4textField = new javax.swing.JTextField();\r\n        button5textField = new javax.swing.JTextField();\r\n        button6textField = new javax.swing.JTextField();\r\n        button7textField = new javax.swing.JTextField();\r\n\r\n        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\r\n\r\n        jLabel1.setFont(new java.awt.Font(\"Lucida Grande\", 1, 14)); // NOI18N\r\n        jLabel1.setText(\"IMDb Actor/Movie Catalog - EDA16-17-  \");\r\n\r\n        button1.setText(\"(1)\");\r\n        button1.addActionListener(evt -> button1ActionPerformed());\r\n\r\n        button2.setText(\"(2)\");\r\n        button2.addActionListener(new java.awt.event.ActionListener() {\r\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\r\n                button2ActionPerformed();\r\n            }\r\n        });\r\n\r\n        button3.setText(\"(3)\");\r\n        button3.addActionListener(evt -> button3ActionPerformed());\r\n\r\n        jLabel2.setText(\"Read data from file\");\r\n\r\n        jLabel3.setText(\"Search for an actor/actress\");\r\n\r\n        jLabel4.setText(\"Add a new actor/actress\");\r\n\r\n        button4.setText(\"(4)\");\r\n        button4.addActionListener(evt -> button4ActionPerformed());\r\n\r\n        jLabel5.setText(\"Search for films of a particular actor\");\r\n\r\n        button5.setText(\"(5)\");\r\n        button5.addActionListener(evt -> button5ActionPerformed());\r\n\r\n        jLabel6.setText(\"Search for actors of a particular film\");\r\n\r\n        button6.setText(\"(6)\");\r\n        button6.addActionListener(evt -> button6ActionPerformed());\r\n\r\n\r\n        jLabel7.setText(\"Increase the money raised by a film\");\r\n\r\n        button7.setText(\"(7)\");\r\n        button7.addActionListener(evt -> button7ActionPerformed());\r\n\r\n        jLabel8.setText(\"Erase an actor/actress\");\r\n\r\n        button8.setText(\"(8)\");\r\n        button8.addActionListener(evt -> button8ActionPerformed());\r\n\r\n        jLabel9.setText(\"Obtain an ordered list of actors (name, surname)\");\r\n\r\n        button9.setText(\"(9)\");\r\n        button9.addActionListener(evt -> button9ActionPerformed());\r\n\r\n        jLabel10.setText(\"Save/Export the list to a file\");\r\n\r\n        button2textField.setText(\"Actor/Actress name to search for\");\r\n\r\n        button3textField.setText(\"Actor/Actress name to add\");\r\n\r\n        button4textField.setText(\"Name of the film\");\r\n\r\n        button5textField.setText(\"Name of the actor/actress\");\r\n\r\n        button6textField.setText(\"Amount of money to increase\");\r\n        button6textField.setVisible(false);\r\n\r\n        button7textField.setText(\"Actor/Actress name to delete\");\r\n\r\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\r\n        getContentPane().setLayout(layout);\r\n        layout.setHorizontalGroup(\r\n                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\r\n                        .addGroup(layout.createSequentialGroup()\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\r\n                                        .addGroup(layout.createSequentialGroup()\r\n                                                .addGap(106, 106, 106)\r\n                                                .addComponent(jLabel1))\r\n                                        .addGroup(layout.createSequentialGroup()\r\n                                                .addContainerGap()\r\n                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\r\n                                                        .addComponent(button9, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button8, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button7, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button6, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button5, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)\r\n                                                        .addComponent(button1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel2)\r\n                                                                .addGap(18, 18, 18)\r\n                                                                .addComponent(jProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 167, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel3)\r\n                                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\r\n                                                                .addComponent(button2textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel4)\r\n                                                                .addGap(18, 18, 18)\r\n                                                                .addComponent(button3textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel5)\r\n                                                                .addGap(18, 18, 18)\r\n                                                                .addComponent(button4textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel6)\r\n                                                                .addGap(18, 18, 18)\r\n                                                                .addComponent(button5textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel7)\r\n                                                                .addGap(18, 18, 18)\r\n                                                                .addComponent(button6textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addGroup(layout.createSequentialGroup()\r\n                                                                .addComponent(jLabel8)\r\n                                                                .addGap(18, 18, 18)\r\n                                                                .addComponent(button7textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                                        .addComponent(jLabel9)\r\n                                                        .addComponent(jLabel10))))\r\n                                .addContainerGap(34, Short.MAX_VALUE))\r\n        );\r\n        layout.setVerticalGroup(\r\n                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\r\n                        .addGroup(layout.createSequentialGroup()\r\n                                .addContainerGap()\r\n                                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)\r\n                                .addGap(18, 18, 18)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\r\n                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                                .addComponent(button1)\r\n                                                .addComponent(jLabel2))\r\n                                        .addComponent(jProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button2)\r\n                                        .addComponent(jLabel3)\r\n                                        .addComponent(button2textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button3)\r\n                                        .addComponent(jLabel4)\r\n                                        .addComponent(button3textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button4)\r\n                                        .addComponent(jLabel5)\r\n                                        .addComponent(button4textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button5)\r\n                                        .addComponent(jLabel6)\r\n                                        .addComponent(button5textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button6)\r\n                                        .addComponent(jLabel7)\r\n                                        .addComponent(button6textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button7)\r\n                                        .addComponent(jLabel8)\r\n                                        .addComponent(button7textField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button8)\r\n                                        .addComponent(jLabel9))\r\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\r\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\r\n                                        .addComponent(button9)\r\n                                        .addComponent(jLabel10))\r\n                                .addContainerGap(12, Short.MAX_VALUE))\r\n        );\r\n\r\n        pack();\r\n    }\r\n\r\n    private void button1ActionPerformed( ) {\r\n        try {\r\n            jProgressBar.setMinimum(0);\r\n            jProgressBar.setMaximum(100);\r\n            FileManager.getMyFileManager().readFile(1);\r\n        } catch (FileNotFoundException e1) {\r\n            System.out.println(\"File not found. ¿Are you sure that you're opening the correct file?\");\r\n        } catch (IOException e2) {\r\n            System.out.println(\"IOException when counting lines for the progress bar\");\r\n        }\r\n\r\n    }\r\n\r\n    private void button2ActionPerformed() {\r\n        String auxActorName = button2textField.getText();\r\n        String[] auxActorArray = auxActorName.split(\"\\\\s\");\r\n        auxActorName = auxActorArray[0];\r\n        String auxActorSurname = auxActorArray[1];\r\n        Actor auxActor = new Actor(auxActorName, auxActorSurname);\r\n        Actor actor = ActorCatalog.getmyActorCatalog().searchActor(auxActor);\r\n        if (actor != null) {\r\n            System.out.println(\"Actor finded. \" + actor.getName() + \" \" + actor.getSurname());\r\n        } else {\r\n            System.out.println(\"Actor: \" + button2textField.getText() + \" not found\");\r\n        }\r\n    }\r\n\r\n    private void button3ActionPerformed() {\r\n        String auxActorName = button3textField.getText();\r\n        String[] auxActorArray = auxActorName.split(\"\\\\s\");\r\n        auxActorName = auxActorArray[0];\r\n        String auxActorSurname = auxActorArray[1];\r\n        Actor auxActor = new Actor(auxActorName, auxActorSurname);\r\n        if (ActorCatalog.getmyActorCatalog().searchActor(auxActor) != null) {\r\n            System.out.println(\"Actor already exists\");\r\n        } else {\r\n            ActorCatalog.getmyActorCatalog().addActor(auxActor);\r\n        }\r\n    }\r\n\r\n    private void button4ActionPerformed() {\r\n        String auxActorName = button4textField.getText();\r\n        String[] auxActorArray = auxActorName.split(\"\\\\s\");\r\n        auxActorName = auxActorArray[0];\r\n        String auxActorSurname = auxActorArray[1];\r\n        Actor auxActor = new Actor(auxActorName, auxActorSurname);\r\n        if (ActorCatalog.getmyActorCatalog().searchActor(auxActor) != null) {\r\n            ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)).getFilmList().printFilms();\r\n        } else {\r\n            System.out.println(\"Not posible to erase. Actor doesn't exist\");\r\n        }\r\n\r\n    }\r\n\r\n    private void button5ActionPerformed() {\r\n        String auxFilmName = button5textField.getText();\r\n        if (FilmCatalog.getMyFilmCatalog().getFilm(auxFilmName) != null) {\r\n            FilmCatalog.getMyFilmCatalog().getFilm(auxFilmName).getActorList().printActors();\r\n        }\r\n    }\r\n\r\n    private void button6ActionPerformed() {\r\n        JTextField filmName = new JTextField(15);\r\n        JTextField moneyQuantity = new JTextField(15);\r\n\r\n        JPanel myPanel = new JPanel();\r\n        myPanel.add(new JLabel(\"Film name:\"));\r\n        myPanel.add(filmName);\r\n        myPanel.add(Box.createHorizontalStrut(15)); // a spacer\r\n        myPanel.add(new JLabel(\"Money quantity:\"));\r\n        myPanel.add(moneyQuantity);\r\n\r\n        JOptionPane.showConfirmDialog(null, myPanel,\r\n                \"Please enter filmName and moneyQuantity values\", JOptionPane.OK_CANCEL_OPTION);\r\n        try {\r\n            FilmCatalog.getMyFilmCatalog().getFilm(filmName.getText()).incrementEarned(Integer.parseInt(moneyQuantity.getText()));\r\n            System.out.println(\"Total earned by the film: \" + FilmCatalog.getMyFilmCatalog().getFilm(filmName.getText()).getEarned());\r\n        } catch (NullPointerException e1) {\r\n            System.out.println(\"File not found or invalid moneyQuantity\");\r\n        }\r\n    }\r\n\r\n    private void button7ActionPerformed() {\r\n        String auxActorName = button7textField.getText();\r\n        String[] auxActorArray = auxActorName.split(\"\\\\s\");\r\n        auxActorName = auxActorArray[0];\r\n        String auxActorSurname = auxActorArray[1];\r\n        try {\r\n            ActorCatalog.getmyActorCatalog().removeActor(new Actor(auxActorName, auxActorSurname));\r\n        } catch (NullPointerException e1) {\r\n            System.out.println(\"Actor not found\");\r\n        }\r\n    }\r\n\r\n    private void button8ActionPerformed() {\r\n        ActorCatalog.getmyActorCatalog().quickSortList();\r\n    }\r\n\r\n    private void button9ActionPerformed() {\r\n        try {\r\n            FileManager.getMyFileManager().exportToFile();\r\n        } catch (Exception e1) {\r\n            System.out.println(\"Error during operation\");\r\n        }\r\n    }\r\n\r\n    public void updateBar(int pNewValue) {\r\n        jProgressBar.setValue(pNewValue);\r\n    }\r\n}\r\n```\r\n### 5.13 TerminalGUI\r\n```java\r\npublic class TerminalUI {\r\n\r\n    private static TerminalUI myTerminalGUI;\r\n    private Scanner optMenu;\r\n\r\n    private TerminalUI() {\r\n        optMenu = new Scanner(System.in);\r\n    }\r\n\r\n    public static TerminalUI getMyTerminalGUI() {\r\n        if (myTerminalGUI == null) {\r\n            myTerminalGUI = new TerminalUI();\r\n        }\r\n        return myTerminalGUI;\r\n    }\r\n\r\n    public static void main() throws FileNotFoundException {\r\n\r\n        String[] auxActorArray;\r\n        String auxActorName;\r\n        String auxActorSurname;\r\n\r\n        String auxS;\r\n\r\n        System.out.println(\"\\t\\t\\t***-----Welcome to our IMDb EDA16/17 project menu-----***\");\r\n\r\n        do {\r\n            System.out.println(\"\\n\\t\\t\\t----------MENU----------\");\r\n            System.out.println(\"\\t\\t1) Read data from file\");\r\n            System.out.println(\"\\t\\t2) Search for an actor/actress\");\r\n            System.out.println(\"\\t\\t3) Add a new actor/actress\");\r\n            System.out.println(\"\\t\\t4) Search for films of a particular actor\");\r\n            System.out.println(\"\\t\\t5) Search for actor of a particular film\");\r\n            System.out.println(\"\\t\\t6) Increase the money raised by a film\");\r\n            System.out.println(\"\\t\\t7) Erase an actor/actress\");\r\n            System.out.println(\"\\t\\t8) Obtain an ordered list of actor (name,surname)\");\r\n            System.out.println(\"\\t\\t9) Save/Export the new list to a file\");\r\n\r\n            int optMenu = Keyboard.getMyKeyboard().getInt();\r\n\r\n            switch (optMenu) {\r\n                case 0:\r\n                    System.out.println(\"\\t\\t--- Saliendo del programa... ----\");\r\n                    break;\r\n                case 1:\r\n                    try {\r\n                        System.out.println(\"\\tSelect one of options below: \");\r\n                        System.out.println(\"\\t\\t1) Read only the 'readable' actors/films (after trying to rescue some names from the codification, take only the 'full readables') \");\r\n                        System.out.println(\"\\t\\t2) Read the full list of actors/movies (don't care if they're wrong written, after running our conversor\");\r\n                        int optMenu1 = 0;\r\n                        while (optMenu1 < 1 || optMenu1 > 2) {\r\n                            optMenu1 = Keyboard.getMyKeyboard().getInt();\r\n                            if (optMenu1 == 1) {\r\n                                FileManager.getMyFileManager().readFile(1);\r\n                            } else if (optMenu1 == 2) {\r\n                                FileManager.getMyFileManager().readFile(2);\r\n                            } else {\r\n                                System.out.println(\"Invalid option, try again. Select a number between 1-2 range\");\r\n                            }\r\n                        }\r\n\r\n                    } catch (FileNotFoundException e1) {\r\n                        System.out.println(\"File not found. ¿Are you sure that you're opening the correct file?\");\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    System.out.println(\"Enter the name of the actor you want to look for: \");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    auxActorArray = auxS.split(\"\\\\s\");\r\n                    auxActorName = auxActorArray[0];\r\n                    auxActorSurname = auxActorArray[1];\r\n                    Actor auxA = ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname));\r\n                    if (auxA == null) {\r\n                        System.out.println(\"Actor not finded: \" + auxS);\r\n                    } else {\r\n                        System.out.println(\"Actor finded: \" + auxA.getName());\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    System.out.println(\"Enter the name of the actor that you want to add: \");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    auxActorArray = auxS.split(\"\\\\s\");\r\n                    auxActorName = auxActorArray[0];\r\n                    auxActorSurname = auxActorArray[1];\r\n                    if (ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)) != null) {\r\n                        System.out.println(\"Actor: \" + auxS + \" already exist\");\r\n                    } else {\r\n                        ActorCatalog.getmyActorCatalog().addActor(new Actor(auxActorName, auxActorSurname));\r\n                        System.out.println(\"Actor: \" + auxS + \" added to the ActorCatalog\");\r\n                    }\r\n                    break;\r\n                case 4:\r\n                    System.out.println(\"Enter the name of the actor whose films you want to know\");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    auxActorArray = auxS.split(\"\\\\s\");\r\n                    auxActorName = auxActorArray[0];\r\n                    auxActorSurname = auxActorArray[1];\r\n                    if (ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)) != null) {\r\n                        ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)).getFilmList().printFilms();\r\n                    } else {\r\n                        System.out.println(\"Actor: \" + auxS + \" do not exist in the ActorCatalog\");\r\n                    }\r\n                    break;\r\n                case 5:\r\n                    System.out.println(\"Enter the film whose actors that do you want to know: \");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    if (FilmCatalog.getMyFilmCatalog().getFilm(auxS) != null) {\r\n                        FilmCatalog.getMyFilmCatalog().getFilm(auxS).getActorList().printActors();\r\n                    }\r\n                    break;\r\n                case 6:\r\n                    System.out.println(\"Enter the film whose amount of earning you want to raise: \");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    System.out.println(\"Enter the amount of money that you want to increase: \");\r\n                    int auxI = Keyboard.getMyKeyboard().getInt();\r\n                    if (FilmCatalog.getMyFilmCatalog().exist(auxS)) {\r\n                        FilmCatalog.getMyFilmCatalog().getFilm(auxS).incrementEarned(auxI);\r\n                        System.out.println(\"Total earned by the film: \" + FilmCatalog.getMyFilmCatalog().getFilm(auxS).getEarned());\r\n                    } else {\r\n                        System.out.println(\"File not found. Are you sure that you have written title correctly?\");\r\n                    }\r\n                    break;\r\n                case 7:\r\n                    System.out.println(\"Enter the name of the actor that you want to remove\");\r\n                    auxS = Keyboard.getMyKeyboard().getString();\r\n                    auxActorArray = auxS.split(\"\\\\s\");\r\n                    auxActorName = auxActorArray[0];\r\n                    auxActorSurname = auxActorArray[1];\r\n                    if (ActorCatalog.getmyActorCatalog().searchActor(new Actor(auxActorName, auxActorSurname)) != null) {\r\n                        ActorCatalog.getmyActorCatalog().removeActor(new Actor(auxActorName, auxActorSurname));\r\n                        System.out.println(\"Actor: \" + auxS + \" succesfully removed\");\r\n                    } else {\r\n                        System.out.println(\"Actor: \" + auxS + \" do not exist in the ActorCatalog\");\r\n                    }\r\n                    break;\r\n                case 8:\r\n                    ActorCatalog.getmyActorCatalog().quickSortList();\r\n                    break;\r\n                case 9:\r\n                    FileManager.getMyFileManager().exportToFile();\r\n                    break;\r\n            }\r\n        } while (1 != 0);\r\n    }\r\n}\r\n```\r\n### 6. Resultados de las pruebas\r\n\r\n**Estos son los resultados de las pruebas**, en la etapa final de desarrollo (lo que estamos entregando) de la actividad. **Todos los tiempos que mostramos son medias** realizadas (entre 5-10 ejecuciones) **de la misma operación**. Las pruebas **se han realizado en diferentes equipos con diferentes sistemas operativos**, detallamos:\r\n\r\nEn el fichero normalizado encontramos **1 061 522** actores, **230 369** peliculas.\r\nEn el fichero sin normalizar (cogiento toda la informacion, independientemente de si estan bien escritos) encontramos **1 191 316** actores, **238 809** peliculas.\r\n\r\n- **CPU**: Intel i5 6600K 3,9 GHz x 4 cores, **GPU:** nVidia GTX 970 4GB Strix,**RAM:** 16GB DDR5  2666, **SO:** *Windows 10 Pro x64*\r\n\t- Cargar fichero normalizado: \r\n\t- Cargar fichero completo: \r\n\t- Ordenar lista normalizada de actores: \r\n\t- Ordenar lista completa de actores: \r\n\t- Exportar lista normalizada de actores: \r\n\t- Exportar lista completa de actores: \r\n\r\n- **CPU**: Intel i5 2,7 GHz x 2 cores, **GPU:** HD 6100,**RAM:** 8GB LPDDR3  1866, **SO:** *Mac OS Sierra (10.12)*\r\n\t- Cargar fichero normalizado: 20sec\r\n\t- Cargar fichero completo: 26sec\r\n\t- Ordenar lista normalizada de actores: 1sec, 1398000ms\r\n\t- Ordenar lista completa de actores: 1sec, 1376000ms\r\n\t- Exportar lista normalizada de actores: 12sec, 12976000ms\r\n\t- Exportar lista completa de actores: 21sec, 21158000ms\r\n\r\n- **CPU**: Intel Atom Z3775 1,46 GHz x 2 cores, **GPU:** Intel HD Graphics (Bay Trail) (311 - 778 MHz),**RAM:** 2GB RAM 1333, **SO:** *Windows 10 Home x32*\r\n\t- Cargar fichero normalizado: 90sec\r\n\t- Cargar fichero completo: El ordenador no es capaz de leerlo\r\n\t- Ordenar lista normalizada de actores: 2sec, 2312000ms\r\n\t- Ordenar lista completa de actores: No es capaz de leer el fichero completo\r\n\t- Exportar lista normalizada de actores: 78sec, 78051000ms\r\n\t- Exportar lista completa de actores: No es posible leer el fichero completo\r\n\r\n- **CPU**: AMD FX 6300 3,5 GHz x 6 cores, **GPU:** AMD Shappire R7 370 4GB,**RAM:** 16 GB DDR3 1600, **SO:** *Windows Pro x64*\r\n\t- Cargar fichero normalizado: 90sec\r\n\t- Cargar fichero completo: El ordenador no es capaz de leerlo\r\n\t- Ordenar lista normalizada de actores: 2sec, 2312000ms\r\n\t- Ordenar lista completa de actores: No es capaz de leer el fichero completo\r\n\t- Exportar lista normalizada de actores: 78sec, 78051000ms\r\n\t- Exportar lista completa de actores: No es posible leer el fichero completo\r\n\r\n### 7. Conclusiones\r\n\r\nDestacamos como bien hemos indicado, l**a importancia de las búsquedas en el funcionamiento de nuestro programa**. Al tener que trabajarlas tanto, es necesario optimizarlas al máximo para evitar tiempos de ejecución demasiado altos.\r\n\r\n**Otro de los métodos con mucha importancia es cargarFichero()** dado que coge línea a línea el texto que hay en el fichero y lo trata. Es decir, elimina toda la información no relevante para el programa y añade la que si tiene importancia.\r\nMientras trabajamos, como ya hemos comentado, **hicimos una version del programa que trabajaba con búsquedas dicotómicas y el resultado de la experiencia fue darnos cuenta de cuanta importancia podía llegar a tener el mantener la lista ordenada** para evitar usar búsquedas lineales y que el tiempo de ejecución se volviera a disparar.\r\n\r\n**Tras analizar el fichero y destacar un patrón que pudiera servirnos** para, basandonos en el metodo split (de la clase String), separar las lineas del documento en información que nos fuera mas sencilla de manejar; **nos centramos en optimizar al máximo el funcionamiento de esta carga**.\r\nPara realizar la operacion de una forma mas transparente al usuario y sin saturar la ventana de la consola,** hemos desarrollado un metodo que calcula el procentaje actual del documento y la imprime por pantalla en bloques de 10% en 10%** y sin repetirse ninguna de las impresiones.\r\nAsí mismo, **hemos implementado programación basada en multiples procesos para aligerar la carga del fichero con la opción de normalización de nombres que hemos decidido aportar**. Las diferencias las detallaremos ahora con mas datos.\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}